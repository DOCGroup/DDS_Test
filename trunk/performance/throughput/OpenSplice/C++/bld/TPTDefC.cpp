// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:323


#include "TPTDefC.h"
#include "tao/ORB_Core.h"
#include "tao/Typecode.h"
#include "tao/Any_Dual_Impl_T.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "TPTDefC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:65

// Arg traits specializations.
namespace TAO
{
}


// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_QuitMsg[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  24,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d73673a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/QuitMsg:1.0
    8,
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736700),  // name = QuitMsg
  1, // member count
    5,
  ACE_NTOHL (0x71756974), 
  ACE_NTOHL (0x0),  // name = quit
    CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_QuitMsg (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_QuitMsg),
    (char *) &_oc_TP_Test_QuitMsg,
    0,
    sizeof (TP_Test::QuitMsg)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_QuitMsg =
    &_tc_TAO_tc_TP_Test_QuitMsg;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::QuitMsg::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  QuitMsg *_tao_tmp_pointer =
    ACE_static_cast (QuitMsg *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES4SEQUENCE_CS_)
#define _TP_TEST_BYTES4SEQUENCE_CS_

TP_Test::Bytes4Sequence::Bytes4Sequence (void)
{}

TP_Test::Bytes4Sequence::Bytes4Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        4
      >
    (length, buffer, release)
{}

TP_Test::Bytes4Sequence::Bytes4Sequence (
    const Bytes4Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        4
      >
    (seq)
{}

TP_Test::Bytes4Sequence::~Bytes4Sequence (void)
{}

void TP_Test::Bytes4Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes4Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes4Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4Sequence:1.0
    15,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Bytes4Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    4U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes4Sequence),
    (char *) &_oc_TP_Test_Bytes4Sequence,
    0,
    sizeof (TP_Test::Bytes4Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4Sequence =
    &_tc_TAO_tc_TP_Test_Bytes4Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES8SEQUENCE_CS_)
#define _TP_TEST_BYTES8SEQUENCE_CS_

TP_Test::Bytes8Sequence::Bytes8Sequence (void)
{}

TP_Test::Bytes8Sequence::Bytes8Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        8
      >
    (length, buffer, release)
{}

TP_Test::Bytes8Sequence::Bytes8Sequence (
    const Bytes8Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        8
      >
    (seq)
{}

TP_Test::Bytes8Sequence::~Bytes8Sequence (void)
{}

void TP_Test::Bytes8Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes8Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes8Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8Sequence:1.0
    15,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Bytes8Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    8U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes8Sequence),
    (char *) &_oc_TP_Test_Bytes8Sequence,
    0,
    sizeof (TP_Test::Bytes8Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8Sequence =
    &_tc_TAO_tc_TP_Test_Bytes8Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES16SEQUENCE_CS_)
#define _TP_TEST_BYTES16SEQUENCE_CS_

TP_Test::Bytes16Sequence::Bytes16Sequence (void)
{}

TP_Test::Bytes16Sequence::Bytes16Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        16
      >
    (length, buffer, release)
{}

TP_Test::Bytes16Sequence::Bytes16Sequence (
    const Bytes16Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        16
      >
    (seq)
{}

TP_Test::Bytes16Sequence::~Bytes16Sequence (void)
{}

void TP_Test::Bytes16Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes16Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes16Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313653), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16Sequence:1.0
    16,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313653), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Bytes16Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    16U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes16Sequence),
    (char *) &_oc_TP_Test_Bytes16Sequence,
    0,
    sizeof (TP_Test::Bytes16Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16Sequence =
    &_tc_TAO_tc_TP_Test_Bytes16Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES32SEQUENCE_CS_)
#define _TP_TEST_BYTES32SEQUENCE_CS_

TP_Test::Bytes32Sequence::Bytes32Sequence (void)
{}

TP_Test::Bytes32Sequence::Bytes32Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        32
      >
    (length, buffer, release)
{}

TP_Test::Bytes32Sequence::Bytes32Sequence (
    const Bytes32Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        32
      >
    (seq)
{}

TP_Test::Bytes32Sequence::~Bytes32Sequence (void)
{}

void TP_Test::Bytes32Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes32Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes32Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333253), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32Sequence:1.0
    16,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333253), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Bytes32Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    32U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes32Sequence),
    (char *) &_oc_TP_Test_Bytes32Sequence,
    0,
    sizeof (TP_Test::Bytes32Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32Sequence =
    &_tc_TAO_tc_TP_Test_Bytes32Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES64SEQUENCE_CS_)
#define _TP_TEST_BYTES64SEQUENCE_CS_

TP_Test::Bytes64Sequence::Bytes64Sequence (void)
{}

TP_Test::Bytes64Sequence::Bytes64Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        64
      >
    (length, buffer, release)
{}

TP_Test::Bytes64Sequence::Bytes64Sequence (
    const Bytes64Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        64
      >
    (seq)
{}

TP_Test::Bytes64Sequence::~Bytes64Sequence (void)
{}

void TP_Test::Bytes64Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes64Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes64Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363453), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64Sequence:1.0
    16,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363453), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Bytes64Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    64U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes64Sequence),
    (char *) &_oc_TP_Test_Bytes64Sequence,
    0,
    sizeof (TP_Test::Bytes64Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64Sequence =
    &_tc_TAO_tc_TP_Test_Bytes64Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES128SEQUENCE_CS_)
#define _TP_TEST_BYTES128SEQUENCE_CS_

TP_Test::Bytes128Sequence::Bytes128Sequence (void)
{}

TP_Test::Bytes128Sequence::Bytes128Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        128
      >
    (length, buffer, release)
{}

TP_Test::Bytes128Sequence::Bytes128Sequence (
    const Bytes128Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        128
      >
    (seq)
{}

TP_Test::Bytes128Sequence::~Bytes128Sequence (void)
{}

void TP_Test::Bytes128Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes128Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes128Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128Sequence:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Bytes128Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    128U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes128Sequence),
    (char *) &_oc_TP_Test_Bytes128Sequence,
    0,
    sizeof (TP_Test::Bytes128Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128Sequence =
    &_tc_TAO_tc_TP_Test_Bytes128Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES256SEQUENCE_CS_)
#define _TP_TEST_BYTES256SEQUENCE_CS_

TP_Test::Bytes256Sequence::Bytes256Sequence (void)
{}

TP_Test::Bytes256Sequence::Bytes256Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        256
      >
    (length, buffer, release)
{}

TP_Test::Bytes256Sequence::Bytes256Sequence (
    const Bytes256Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        256
      >
    (seq)
{}

TP_Test::Bytes256Sequence::~Bytes256Sequence (void)
{}

void TP_Test::Bytes256Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes256Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes256Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256Sequence:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Bytes256Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    256U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes256Sequence),
    (char *) &_oc_TP_Test_Bytes256Sequence,
    0,
    sizeof (TP_Test::Bytes256Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256Sequence =
    &_tc_TAO_tc_TP_Test_Bytes256Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES512SEQUENCE_CS_)
#define _TP_TEST_BYTES512SEQUENCE_CS_

TP_Test::Bytes512Sequence::Bytes512Sequence (void)
{}

TP_Test::Bytes512Sequence::Bytes512Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        512
      >
    (length, buffer, release)
{}

TP_Test::Bytes512Sequence::Bytes512Sequence (
    const Bytes512Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        512
      >
    (seq)
{}

TP_Test::Bytes512Sequence::~Bytes512Sequence (void)
{}

void TP_Test::Bytes512Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes512Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes512Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512Sequence:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Bytes512Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    512U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes512Sequence),
    (char *) &_oc_TP_Test_Bytes512Sequence,
    0,
    sizeof (TP_Test::Bytes512Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512Sequence =
    &_tc_TAO_tc_TP_Test_Bytes512Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES1024SEQUENCE_CS_)
#define _TP_TEST_BYTES1024SEQUENCE_CS_

TP_Test::Bytes1024Sequence::Bytes1024Sequence (void)
{}

TP_Test::Bytes1024Sequence::Bytes1024Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        1024
      >
    (length, buffer, release)
{}

TP_Test::Bytes1024Sequence::Bytes1024Sequence (
    const Bytes1024Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        1024
      >
    (seq)
{}

TP_Test::Bytes1024Sequence::~Bytes1024Sequence (void)
{}

void TP_Test::Bytes1024Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes1024Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes1024Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024Sequence:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Bytes1024Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    1024U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes1024Sequence),
    (char *) &_oc_TP_Test_Bytes1024Sequence,
    0,
    sizeof (TP_Test::Bytes1024Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024Sequence =
    &_tc_TAO_tc_TP_Test_Bytes1024Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES2048SEQUENCE_CS_)
#define _TP_TEST_BYTES2048SEQUENCE_CS_

TP_Test::Bytes2048Sequence::Bytes2048Sequence (void)
{}

TP_Test::Bytes2048Sequence::Bytes2048Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        2048
      >
    (length, buffer, release)
{}

TP_Test::Bytes2048Sequence::Bytes2048Sequence (
    const Bytes2048Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        2048
      >
    (seq)
{}

TP_Test::Bytes2048Sequence::~Bytes2048Sequence (void)
{}

void TP_Test::Bytes2048Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes2048Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes2048Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048Sequence:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Bytes2048Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    2048U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes2048Sequence),
    (char *) &_oc_TP_Test_Bytes2048Sequence,
    0,
    sizeof (TP_Test::Bytes2048Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048Sequence =
    &_tc_TAO_tc_TP_Test_Bytes2048Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES4096SEQUENCE_CS_)
#define _TP_TEST_BYTES4096SEQUENCE_CS_

TP_Test::Bytes4096Sequence::Bytes4096Sequence (void)
{}

TP_Test::Bytes4096Sequence::Bytes4096Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        4096
      >
    (length, buffer, release)
{}

TP_Test::Bytes4096Sequence::Bytes4096Sequence (
    const Bytes4096Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        4096
      >
    (seq)
{}

TP_Test::Bytes4096Sequence::~Bytes4096Sequence (void)
{}

void TP_Test::Bytes4096Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes4096Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes4096Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096Sequence:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Bytes4096Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    4096U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes4096Sequence),
    (char *) &_oc_TP_Test_Bytes4096Sequence,
    0,
    sizeof (TP_Test::Bytes4096Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096Sequence =
    &_tc_TAO_tc_TP_Test_Bytes4096Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES8192SEQUENCE_CS_)
#define _TP_TEST_BYTES8192SEQUENCE_CS_

TP_Test::Bytes8192Sequence::Bytes8192Sequence (void)
{}

TP_Test::Bytes8192Sequence::Bytes8192Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        8192
      >
    (length, buffer, release)
{}

TP_Test::Bytes8192Sequence::Bytes8192Sequence (
    const Bytes8192Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        8192
      >
    (seq)
{}

TP_Test::Bytes8192Sequence::~Bytes8192Sequence (void)
{}

void TP_Test::Bytes8192Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes8192Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes8192Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192Sequence:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Bytes8192Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    8192U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes8192Sequence),
    (char *) &_oc_TP_Test_Bytes8192Sequence,
    0,
    sizeof (TP_Test::Bytes8192Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192Sequence =
    &_tc_TAO_tc_TP_Test_Bytes8192Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES16384SEQUENCE_CS_)
#define _TP_TEST_BYTES16384SEQUENCE_CS_

TP_Test::Bytes16384Sequence::Bytes16384Sequence (void)
{}

TP_Test::Bytes16384Sequence::Bytes16384Sequence (
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        16384
      >
    (length, buffer, release)
{}

TP_Test::Bytes16384Sequence::Bytes16384Sequence (
    const Bytes16384Sequence &seq
  )
  : TAO_Bounded_Sequence<
        CORBA::Octet,
        16384
      >
    (seq)
{}

TP_Test::Bytes16384Sequence::~Bytes16384Sequence (void)
{}

void TP_Test::Bytes16384Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes16384Sequence * _tao_tmp_pointer =
    ACE_static_cast (Bytes16384Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384Sequence:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Bytes16384Sequence
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    16384U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes16384Sequence),
    (char *) &_oc_TP_Test_Bytes16384Sequence,
    0,
    sizeof (TP_Test::Bytes16384Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384Sequence =
    &_tc_TAO_tc_TP_Test_Bytes16384Sequence;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4:1.0
    7,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73340000),  // name = Bytes4
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73345365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4Sequence:1.0
        15,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73345365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Bytes4Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      4U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes4),
    (char *) &_oc_TP_Test_Bytes4,
    0,
    sizeof (TP_Test::Bytes4)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4 =
    &_tc_TAO_tc_TP_Test_Bytes4;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes4::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes4 *_tao_tmp_pointer =
    ACE_static_cast (Bytes4 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8:1.0
    7,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73380000),  // name = Bytes8
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73385365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8Sequence:1.0
        15,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73385365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Bytes8Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      8U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes8),
    (char *) &_oc_TP_Test_Bytes8,
    0,
    sizeof (TP_Test::Bytes8)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8 =
    &_tc_TAO_tc_TP_Test_Bytes8;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes8::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes8 *_tao_tmp_pointer =
    ACE_static_cast (Bytes8 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  24,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x7331363a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16:1.0
    8,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313600),  // name = Bytes16
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313653), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16Sequence:1.0
        16,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313653), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Bytes16Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      16U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes16),
    (char *) &_oc_TP_Test_Bytes16,
    0,
    sizeof (TP_Test::Bytes16)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16 =
    &_tc_TAO_tc_TP_Test_Bytes16;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes16::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes16 *_tao_tmp_pointer =
    ACE_static_cast (Bytes16 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  24,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x7333323a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32:1.0
    8,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333200),  // name = Bytes32
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73333253), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32Sequence:1.0
        16,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73333253), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Bytes32Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      32U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes32),
    (char *) &_oc_TP_Test_Bytes32,
    0,
    sizeof (TP_Test::Bytes32)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32 =
    &_tc_TAO_tc_TP_Test_Bytes32;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes32::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes32 *_tao_tmp_pointer =
    ACE_static_cast (Bytes32 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  24,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x7336343a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64:1.0
    8,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363400),  // name = Bytes64
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73363453), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64Sequence:1.0
        16,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73363453), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Bytes64Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      64U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes64),
    (char *) &_oc_TP_Test_Bytes64,
    0,
    sizeof (TP_Test::Bytes64)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64 =
    &_tc_TAO_tc_TP_Test_Bytes64;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes64::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes64 *_tao_tmp_pointer =
    ACE_static_cast (Bytes64 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128:1.0
    9,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x0),  // name = Bytes128
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313238), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128Sequence:1.0
        17,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313238), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Bytes128Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      128U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes128),
    (char *) &_oc_TP_Test_Bytes128,
    0,
    sizeof (TP_Test::Bytes128)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128 =
    &_tc_TAO_tc_TP_Test_Bytes128;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes128::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes128 *_tao_tmp_pointer =
    ACE_static_cast (Bytes128 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256:1.0
    9,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x0),  // name = Bytes256
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73323536), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256Sequence:1.0
        17,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73323536), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Bytes256Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      256U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes256),
    (char *) &_oc_TP_Test_Bytes256,
    0,
    sizeof (TP_Test::Bytes256)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256 =
    &_tc_TAO_tc_TP_Test_Bytes256;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes256::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes256 *_tao_tmp_pointer =
    ACE_static_cast (Bytes256 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512:1.0
    9,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x0),  // name = Bytes512
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73353132), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512Sequence:1.0
        17,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73353132), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Bytes512Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      512U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes512),
    (char *) &_oc_TP_Test_Bytes512,
    0,
    sizeof (TP_Test::Bytes512)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512 =
    &_tc_TAO_tc_TP_Test_Bytes512;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes512::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes512 *_tao_tmp_pointer =
    ACE_static_cast (Bytes512 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x343a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34000000),  // name = Bytes1024
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313032), 
    ACE_NTOHL (0x34536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024Sequence:1.0
        18,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313032), 
    ACE_NTOHL (0x34536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Bytes1024Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      1024U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes1024),
    (char *) &_oc_TP_Test_Bytes1024,
    0,
    sizeof (TP_Test::Bytes1024)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024 =
    &_tc_TAO_tc_TP_Test_Bytes1024;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes1024::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes1024 *_tao_tmp_pointer =
    ACE_static_cast (Bytes1024 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x383a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38000000),  // name = Bytes2048
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73323034), 
    ACE_NTOHL (0x38536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048Sequence:1.0
        18,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73323034), 
    ACE_NTOHL (0x38536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Bytes2048Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      2048U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes2048),
    (char *) &_oc_TP_Test_Bytes2048,
    0,
    sizeof (TP_Test::Bytes2048)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048 =
    &_tc_TAO_tc_TP_Test_Bytes2048;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes2048::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes2048 *_tao_tmp_pointer =
    ACE_static_cast (Bytes2048 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x363a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36000000),  // name = Bytes4096
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73343039), 
    ACE_NTOHL (0x36536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096Sequence:1.0
        18,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73343039), 
    ACE_NTOHL (0x36536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Bytes4096Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      4096U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes4096),
    (char *) &_oc_TP_Test_Bytes4096,
    0,
    sizeof (TP_Test::Bytes4096)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096 =
    &_tc_TAO_tc_TP_Test_Bytes4096;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes4096::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes4096 *_tao_tmp_pointer =
    ACE_static_cast (Bytes4096 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x323a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32000000),  // name = Bytes8192
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73383139), 
    ACE_NTOHL (0x32536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192Sequence:1.0
        18,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73383139), 
    ACE_NTOHL (0x32536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Bytes8192Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      8192U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes8192),
    (char *) &_oc_TP_Test_Bytes8192,
    0,
    sizeof (TP_Test::Bytes8192)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192 =
    &_tc_TAO_tc_TP_Test_Bytes8192;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes8192::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes8192 *_tao_tmp_pointer =
    ACE_static_cast (Bytes8192 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38343a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384:1.0
    11,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38340000),  // name = Bytes16384
  2, // member count
    10,
  ACE_NTOHL (0x74696d65), 
  ACE_NTOHL (0x7374616d), 
  ACE_NTOHL (0x70000000),  // name = timestamp
    CORBA::tk_ulong,

  5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313633), 
    ACE_NTOHL (0x38345365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384Sequence:1.0
        19,
    ACE_NTOHL (0x42797465), 
    ACE_NTOHL (0x73313633), 
    ACE_NTOHL (0x38345365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Bytes16384Sequence
        CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      16384U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Bytes16384),
    (char *) &_oc_TP_Test_Bytes16384,
    0,
    sizeof (TP_Test::Bytes16384)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384 =
    &_tc_TAO_tc_TP_Test_Bytes16384;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Bytes16384::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Bytes16384 *_tao_tmp_pointer =
    ACE_static_cast (Bytes16384 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Nested[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  23,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x4e657374), 
  ACE_NTOHL (0x65643a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
    7,
  ACE_NTOHL (0x4e657374), 
  ACE_NTOHL (0x65640000),  // name = Nested
  2, // member count
    5,
  ACE_NTOHL (0x696e666f), 
  ACE_NTOHL (0x0),  // name = info
    CORBA::tk_string, 
  0U, // string length
  6,
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x78000000),  // name = index
    CORBA::tk_long,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Nested (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Nested),
    (char *) &_oc_TP_Test_Nested,
    0,
    sizeof (TP_Test::Nested)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Nested =
    &_tc_TAO_tc_TP_Test_Nested;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Nested::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Nested *_tao_tmp_pointer =
    ACE_static_cast (Nested *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_NESTEDSEQUENCE_CS_)
#define _TP_TEST_NESTEDSEQUENCE_CS_

TP_Test::NestedSequence::NestedSequence (void)
{}

TP_Test::NestedSequence::NestedSequence (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Nested
      >
    (max)
{}

TP_Test::NestedSequence::NestedSequence (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Nested * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Nested
      >
    (max, length, buffer, release)
{}

TP_Test::NestedSequence::NestedSequence (
    const NestedSequence &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Nested
      >
    (seq)
{}

TP_Test::NestedSequence::~NestedSequence (void)
{}

void TP_Test::NestedSequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  NestedSequence * _tao_tmp_pointer =
    ACE_static_cast (NestedSequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_NestedSequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x4e657374), 
  ACE_NTOHL (0x65645365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
    15,
  ACE_NTOHL (0x4e657374), 
  ACE_NTOHL (0x65645365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = NestedSequence
    CORBA::tk_sequence, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      23,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4e657374), 
      ACE_NTOHL (0x65643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
            7,
      ACE_NTOHL (0x4e657374), 
      ACE_NTOHL (0x65640000),  // name = Nested
      2, // member count
            5,
      ACE_NTOHL (0x696e666f), 
      ACE_NTOHL (0x0),  // name = info
            CORBA::tk_string, 
      0U, // string length
      6,
      ACE_NTOHL (0x696e6465), 
      ACE_NTOHL (0x78000000),  // name = index
            CORBA::tk_long,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_NestedSequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_NestedSequence),
    (char *) &_oc_TP_Test_NestedSequence,
    0,
    sizeof (TP_Test::NestedSequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_NestedSequence =
    &_tc_TAO_tc_TP_Test_NestedSequence;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Outer[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  22,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x4f757465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
    6,
  ACE_NTOHL (0x4f757465), 
  ACE_NTOHL (0x72000000),  // name = Outer
  2, // member count
    7,
  ACE_NTOHL (0x6c656e67), 
  ACE_NTOHL (0x74680000),  // name = length
    CORBA::tk_long,

  14,
  ACE_NTOHL (0x6e657374), 
  ACE_NTOHL (0x65645f6d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x72000000),  // name = nested_member
    CORBA::tk_alias, // typecode kind for typedefs
  168, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x4e657374), 
    ACE_NTOHL (0x65645365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
        15,
    ACE_NTOHL (0x4e657374), 
    ACE_NTOHL (0x65645365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = NestedSequence
        CORBA::tk_sequence, // typecode kind
    100, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      84, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        23,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                7,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65640000),  // name = Nested
        2, // member count
                5,
        ACE_NTOHL (0x696e666f), 
        ACE_NTOHL (0x0),  // name = info
                CORBA::tk_string, 
        0U, // string length
        6,
        ACE_NTOHL (0x696e6465), 
        ACE_NTOHL (0x78000000),  // name = index
                CORBA::tk_long,


      0U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Outer (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Outer),
    (char *) &_oc_TP_Test_Outer,
    0,
    sizeof (TP_Test::Outer)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Outer =
    &_tc_TAO_tc_TP_Test_Outer;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Outer::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Outer *_tao_tmp_pointer =
    ACE_static_cast (Outer *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX4SEQUENCE_CS_)
#define _TP_TEST_COMPLEX4SEQUENCE_CS_

TP_Test::Complex4Sequence::Complex4Sequence (void)
{}

TP_Test::Complex4Sequence::Complex4Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        4
      >
    (length, buffer, release)
{}

TP_Test::Complex4Sequence::Complex4Sequence (
    const Complex4Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        4
      >
    (seq)
{}

TP_Test::Complex4Sequence::~Complex4Sequence (void)
{}

void TP_Test::Complex4Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex4Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex4Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4Sequence:1.0
    17,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Complex4Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    4U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex4Sequence),
    (char *) &_oc_TP_Test_Complex4Sequence,
    0,
    sizeof (TP_Test::Complex4Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4Sequence =
    &_tc_TAO_tc_TP_Test_Complex4Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX8SEQUENCE_CS_)
#define _TP_TEST_COMPLEX8SEQUENCE_CS_

TP_Test::Complex8Sequence::Complex8Sequence (void)
{}

TP_Test::Complex8Sequence::Complex8Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        8
      >
    (length, buffer, release)
{}

TP_Test::Complex8Sequence::Complex8Sequence (
    const Complex8Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        8
      >
    (seq)
{}

TP_Test::Complex8Sequence::~Complex8Sequence (void)
{}

void TP_Test::Complex8Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex8Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex8Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8Sequence:1.0
    17,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Complex8Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    8U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex8Sequence),
    (char *) &_oc_TP_Test_Complex8Sequence,
    0,
    sizeof (TP_Test::Complex8Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8Sequence =
    &_tc_TAO_tc_TP_Test_Complex8Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX16SEQUENCE_CS_)
#define _TP_TEST_COMPLEX16SEQUENCE_CS_

TP_Test::Complex16Sequence::Complex16Sequence (void)
{}

TP_Test::Complex16Sequence::Complex16Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        16
      >
    (length, buffer, release)
{}

TP_Test::Complex16Sequence::Complex16Sequence (
    const Complex16Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        16
      >
    (seq)
{}

TP_Test::Complex16Sequence::~Complex16Sequence (void)
{}

void TP_Test::Complex16Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex16Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex16Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16Sequence:1.0
    18,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Complex16Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    16U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex16Sequence),
    (char *) &_oc_TP_Test_Complex16Sequence,
    0,
    sizeof (TP_Test::Complex16Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16Sequence =
    &_tc_TAO_tc_TP_Test_Complex16Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX32SEQUENCE_CS_)
#define _TP_TEST_COMPLEX32SEQUENCE_CS_

TP_Test::Complex32Sequence::Complex32Sequence (void)
{}

TP_Test::Complex32Sequence::Complex32Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        32
      >
    (length, buffer, release)
{}

TP_Test::Complex32Sequence::Complex32Sequence (
    const Complex32Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        32
      >
    (seq)
{}

TP_Test::Complex32Sequence::~Complex32Sequence (void)
{}

void TP_Test::Complex32Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex32Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex32Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32Sequence:1.0
    18,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Complex32Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    32U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex32Sequence),
    (char *) &_oc_TP_Test_Complex32Sequence,
    0,
    sizeof (TP_Test::Complex32Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32Sequence =
    &_tc_TAO_tc_TP_Test_Complex32Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX64SEQUENCE_CS_)
#define _TP_TEST_COMPLEX64SEQUENCE_CS_

TP_Test::Complex64Sequence::Complex64Sequence (void)
{}

TP_Test::Complex64Sequence::Complex64Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        64
      >
    (length, buffer, release)
{}

TP_Test::Complex64Sequence::Complex64Sequence (
    const Complex64Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        64
      >
    (seq)
{}

TP_Test::Complex64Sequence::~Complex64Sequence (void)
{}

void TP_Test::Complex64Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex64Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex64Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64Sequence:1.0
    18,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x75656e63), 
  ACE_NTOHL (0x65000000),  // name = Complex64Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    64U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex64Sequence),
    (char *) &_oc_TP_Test_Complex64Sequence,
    0,
    sizeof (TP_Test::Complex64Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64Sequence =
    &_tc_TAO_tc_TP_Test_Complex64Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX128SEQUENCE_CS_)
#define _TP_TEST_COMPLEX128SEQUENCE_CS_

TP_Test::Complex128Sequence::Complex128Sequence (void)
{}

TP_Test::Complex128Sequence::Complex128Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        128
      >
    (length, buffer, release)
{}

TP_Test::Complex128Sequence::Complex128Sequence (
    const Complex128Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        128
      >
    (seq)
{}

TP_Test::Complex128Sequence::~Complex128Sequence (void)
{}

void TP_Test::Complex128Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex128Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex128Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128Sequence:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Complex128Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    128U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex128Sequence),
    (char *) &_oc_TP_Test_Complex128Sequence,
    0,
    sizeof (TP_Test::Complex128Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128Sequence =
    &_tc_TAO_tc_TP_Test_Complex128Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX256SEQUENCE_CS_)
#define _TP_TEST_COMPLEX256SEQUENCE_CS_

TP_Test::Complex256Sequence::Complex256Sequence (void)
{}

TP_Test::Complex256Sequence::Complex256Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        256
      >
    (length, buffer, release)
{}

TP_Test::Complex256Sequence::Complex256Sequence (
    const Complex256Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        256
      >
    (seq)
{}

TP_Test::Complex256Sequence::~Complex256Sequence (void)
{}

void TP_Test::Complex256Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex256Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex256Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256Sequence:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Complex256Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    256U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex256Sequence),
    (char *) &_oc_TP_Test_Complex256Sequence,
    0,
    sizeof (TP_Test::Complex256Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256Sequence =
    &_tc_TAO_tc_TP_Test_Complex256Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX512SEQUENCE_CS_)
#define _TP_TEST_COMPLEX512SEQUENCE_CS_

TP_Test::Complex512Sequence::Complex512Sequence (void)
{}

TP_Test::Complex512Sequence::Complex512Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        512
      >
    (length, buffer, release)
{}

TP_Test::Complex512Sequence::Complex512Sequence (
    const Complex512Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        512
      >
    (seq)
{}

TP_Test::Complex512Sequence::~Complex512Sequence (void)
{}

void TP_Test::Complex512Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex512Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex512Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512Sequence:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63650000),  // name = Complex512Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    512U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex512Sequence),
    (char *) &_oc_TP_Test_Complex512Sequence,
    0,
    sizeof (TP_Test::Complex512Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512Sequence =
    &_tc_TAO_tc_TP_Test_Complex512Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX1024SEQUENCE_CS_)
#define _TP_TEST_COMPLEX1024SEQUENCE_CS_

TP_Test::Complex1024Sequence::Complex1024Sequence (void)
{}

TP_Test::Complex1024Sequence::Complex1024Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        1024
      >
    (length, buffer, release)
{}

TP_Test::Complex1024Sequence::Complex1024Sequence (
    const Complex1024Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        1024
      >
    (seq)
{}

TP_Test::Complex1024Sequence::~Complex1024Sequence (void)
{}

void TP_Test::Complex1024Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex1024Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex1024Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323453), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024Sequence:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323453), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Complex1024Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    1024U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex1024Sequence),
    (char *) &_oc_TP_Test_Complex1024Sequence,
    0,
    sizeof (TP_Test::Complex1024Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024Sequence =
    &_tc_TAO_tc_TP_Test_Complex1024Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX2048SEQUENCE_CS_)
#define _TP_TEST_COMPLEX2048SEQUENCE_CS_

TP_Test::Complex2048Sequence::Complex2048Sequence (void)
{}

TP_Test::Complex2048Sequence::Complex2048Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        2048
      >
    (length, buffer, release)
{}

TP_Test::Complex2048Sequence::Complex2048Sequence (
    const Complex2048Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        2048
      >
    (seq)
{}

TP_Test::Complex2048Sequence::~Complex2048Sequence (void)
{}

void TP_Test::Complex2048Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex2048Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex2048Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343853), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048Sequence:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343853), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Complex2048Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    2048U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex2048Sequence),
    (char *) &_oc_TP_Test_Complex2048Sequence,
    0,
    sizeof (TP_Test::Complex2048Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048Sequence =
    &_tc_TAO_tc_TP_Test_Complex2048Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX4096SEQUENCE_CS_)
#define _TP_TEST_COMPLEX4096SEQUENCE_CS_

TP_Test::Complex4096Sequence::Complex4096Sequence (void)
{}

TP_Test::Complex4096Sequence::Complex4096Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        4096
      >
    (length, buffer, release)
{}

TP_Test::Complex4096Sequence::Complex4096Sequence (
    const Complex4096Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        4096
      >
    (seq)
{}

TP_Test::Complex4096Sequence::~Complex4096Sequence (void)
{}

void TP_Test::Complex4096Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex4096Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex4096Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393653), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096Sequence:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393653), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Complex4096Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    4096U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex4096Sequence),
    (char *) &_oc_TP_Test_Complex4096Sequence,
    0,
    sizeof (TP_Test::Complex4096Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096Sequence =
    &_tc_TAO_tc_TP_Test_Complex4096Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX8192SEQUENCE_CS_)
#define _TP_TEST_COMPLEX8192SEQUENCE_CS_

TP_Test::Complex8192Sequence::Complex8192Sequence (void)
{}

TP_Test::Complex8192Sequence::Complex8192Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        8192
      >
    (length, buffer, release)
{}

TP_Test::Complex8192Sequence::Complex8192Sequence (
    const Complex8192Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        8192
      >
    (seq)
{}

TP_Test::Complex8192Sequence::~Complex8192Sequence (void)
{}

void TP_Test::Complex8192Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex8192Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex8192Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393253), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e63653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192Sequence:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393253), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = Complex8192Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    8192U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex8192Sequence),
    (char *) &_oc_TP_Test_Complex8192Sequence,
    0,
    sizeof (TP_Test::Complex8192Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192Sequence =
    &_tc_TAO_tc_TP_Test_Complex8192Sequence;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX16384SEQUENCE_CS_)
#define _TP_TEST_COMPLEX16384SEQUENCE_CS_

TP_Test::Complex16384Sequence::Complex16384Sequence (void)
{}

TP_Test::Complex16384Sequence::Complex16384Sequence (
    CORBA::ULong length,
    TP_Test::Outer * buffer,
    CORBA::Boolean release
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        16384
      >
    (length, buffer, release)
{}

TP_Test::Complex16384Sequence::Complex16384Sequence (
    const Complex16384Sequence &seq
  )
  : TAO_Bounded_Sequence<
        TP_Test::Outer,
        16384
      >
    (seq)
{}

TP_Test::Complex16384Sequence::~Complex16384Sequence (void)
{}

void TP_Test::Complex16384Sequence::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex16384Sequence * _tao_tmp_pointer =
    ACE_static_cast (Complex16384Sequence *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384Sequence[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384Sequence:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x0),  // name = Complex16384Sequence
    CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      22,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
            6,
      ACE_NTOHL (0x4f757465), 
      ACE_NTOHL (0x72000000),  // name = Outer
      2, // member count
            7,
      ACE_NTOHL (0x6c656e67), 
      ACE_NTOHL (0x74680000),  // name = length
            CORBA::tk_long,

      14,
      ACE_NTOHL (0x6e657374), 
      ACE_NTOHL (0x65645f6d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x72000000),  // name = nested_member
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                15,
        ACE_NTOHL (0x4e657374), 
        ACE_NTOHL (0x65645365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = NestedSequence
                CORBA::tk_sequence, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          84, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            23,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                        7,
            ACE_NTOHL (0x4e657374), 
            ACE_NTOHL (0x65640000),  // name = Nested
            2, // member count
                        5,
            ACE_NTOHL (0x696e666f), 
            ACE_NTOHL (0x0),  // name = info
                        CORBA::tk_string, 
            0U, // string length
            6,
            ACE_NTOHL (0x696e6465), 
            ACE_NTOHL (0x78000000),  // name = index
                        CORBA::tk_long,


          0U,



    16384U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384Sequence (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex16384Sequence),
    (char *) &_oc_TP_Test_Complex16384Sequence,
    0,
    sizeof (TP_Test::Complex16384Sequence)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384Sequence =
    &_tc_TAO_tc_TP_Test_Complex16384Sequence;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4:1.0
    9,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x0),  // name = Complex4
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657834), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4Sequence:1.0
        17,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657834), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Complex4Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      4U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex4),
    (char *) &_oc_TP_Test_Complex4,
    0,
    sizeof (TP_Test::Complex4)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4 =
    &_tc_TAO_tc_TP_Test_Complex4;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex4::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex4 *_tao_tmp_pointer =
    ACE_static_cast (Complex4 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  25,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8:1.0
    9,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x0),  // name = Complex8
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657838), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8Sequence:1.0
        17,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657838), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Complex8Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      8U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex8),
    (char *) &_oc_TP_Test_Complex8,
    0,
    sizeof (TP_Test::Complex8)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8 =
    &_tc_TAO_tc_TP_Test_Complex8;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex8::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex8 *_tao_tmp_pointer =
    ACE_static_cast (Complex8 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x363a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16:1.0
    10,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36000000),  // name = Complex16
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x36536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16Sequence:1.0
        18,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x36536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Complex16Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      16U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex16),
    (char *) &_oc_TP_Test_Complex16,
    0,
    sizeof (TP_Test::Complex16)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16 =
    &_tc_TAO_tc_TP_Test_Complex16;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex16::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex16 *_tao_tmp_pointer =
    ACE_static_cast (Complex16 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x323a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32:1.0
    10,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32000000),  // name = Complex32
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657833), 
    ACE_NTOHL (0x32536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32Sequence:1.0
        18,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657833), 
    ACE_NTOHL (0x32536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Complex32Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      32U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex32),
    (char *) &_oc_TP_Test_Complex32,
    0,
    sizeof (TP_Test::Complex32)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32 =
    &_tc_TAO_tc_TP_Test_Complex32;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex32::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex32 *_tao_tmp_pointer =
    ACE_static_cast (Complex32 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x343a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64:1.0
    10,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34000000),  // name = Complex64
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657836), 
    ACE_NTOHL (0x34536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64Sequence:1.0
        18,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657836), 
    ACE_NTOHL (0x34536571), 
    ACE_NTOHL (0x75656e63), 
    ACE_NTOHL (0x65000000),  // name = Complex64Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      64U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex64),
    (char *) &_oc_TP_Test_Complex64,
    0,
    sizeof (TP_Test::Complex64)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64 =
    &_tc_TAO_tc_TP_Test_Complex64;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex64::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex64 *_tao_tmp_pointer =
    ACE_static_cast (Complex64 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32383a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128:1.0
    11,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32380000),  // name = Complex128
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x32385365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128Sequence:1.0
        19,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x32385365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Complex128Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      128U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex128),
    (char *) &_oc_TP_Test_Complex128,
    0,
    sizeof (TP_Test::Complex128)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128 =
    &_tc_TAO_tc_TP_Test_Complex128;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex128::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex128 *_tao_tmp_pointer =
    ACE_static_cast (Complex128 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35363a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256:1.0
    11,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35360000),  // name = Complex256
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657832), 
    ACE_NTOHL (0x35365365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256Sequence:1.0
        19,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657832), 
    ACE_NTOHL (0x35365365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Complex256Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      256U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex256),
    (char *) &_oc_TP_Test_Complex256,
    0,
    sizeof (TP_Test::Complex256)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256 =
    &_tc_TAO_tc_TP_Test_Complex256;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex256::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex256 *_tao_tmp_pointer =
    ACE_static_cast (Complex256 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31323a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512:1.0
    11,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31320000),  // name = Complex512
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657835), 
    ACE_NTOHL (0x31325365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512Sequence:1.0
        19,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657835), 
    ACE_NTOHL (0x31325365), 
    ACE_NTOHL (0x7175656e), 
    ACE_NTOHL (0x63650000),  // name = Complex512Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      512U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex512),
    (char *) &_oc_TP_Test_Complex512,
    0,
    sizeof (TP_Test::Complex512)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512 =
    &_tc_TAO_tc_TP_Test_Complex512;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex512::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex512 *_tao_tmp_pointer =
    ACE_static_cast (Complex512 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x3032343a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323400),  // name = Complex1024
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x30323453), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024Sequence:1.0
        20,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x30323453), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Complex1024Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      1024U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex1024),
    (char *) &_oc_TP_Test_Complex1024,
    0,
    sizeof (TP_Test::Complex1024)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024 =
    &_tc_TAO_tc_TP_Test_Complex1024;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex1024::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex1024 *_tao_tmp_pointer =
    ACE_static_cast (Complex1024 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x3034383a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343800),  // name = Complex2048
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657832), 
    ACE_NTOHL (0x30343853), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048Sequence:1.0
        20,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657832), 
    ACE_NTOHL (0x30343853), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Complex2048Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      2048U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex2048),
    (char *) &_oc_TP_Test_Complex2048,
    0,
    sizeof (TP_Test::Complex2048)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048 =
    &_tc_TAO_tc_TP_Test_Complex2048;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex2048::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex2048 *_tao_tmp_pointer =
    ACE_static_cast (Complex2048 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x3039363a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393600),  // name = Complex4096
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657834), 
    ACE_NTOHL (0x30393653), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096Sequence:1.0
        20,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657834), 
    ACE_NTOHL (0x30393653), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Complex4096Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      4096U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex4096),
    (char *) &_oc_TP_Test_Complex4096,
    0,
    sizeof (TP_Test::Complex4096)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096 =
    &_tc_TAO_tc_TP_Test_Complex4096;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex4096::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex4096 *_tao_tmp_pointer =
    ACE_static_cast (Complex4096 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x3139323a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393200),  // name = Complex8192
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  352, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657838), 
    ACE_NTOHL (0x31393253), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e63653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192Sequence:1.0
        20,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657838), 
    ACE_NTOHL (0x31393253), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = Complex8192Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      8192U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex8192),
    (char *) &_oc_TP_Test_Complex8192,
    0,
    sizeof (TP_Test::Complex8192)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192 =
    &_tc_TAO_tc_TP_Test_Complex8192;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex8192::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex8192 *_tao_tmp_pointer =
    ACE_static_cast (Complex8192 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384:1.0
    13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x0),  // name = Complex16384
  1, // member count
    5,
  ACE_NTOHL (0x64617461), 
  ACE_NTOHL (0x0),  // name = data
    CORBA::tk_alias, // typecode kind for typedefs
  360, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x54505f54), 
    ACE_NTOHL (0x6573742f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x36333834), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384Sequence:1.0
        21,
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6c657831), 
    ACE_NTOHL (0x36333834), 
    ACE_NTOHL (0x53657175), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x0),  // name = Complex16384Sequence
        CORBA::tk_sequence, // typecode kind
    276, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      260, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        22,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                6,
        ACE_NTOHL (0x4f757465), 
        ACE_NTOHL (0x72000000),  // name = Outer
        2, // member count
                7,
        ACE_NTOHL (0x6c656e67), 
        ACE_NTOHL (0x74680000),  // name = length
                CORBA::tk_long,

        14,
        ACE_NTOHL (0x6e657374), 
        ACE_NTOHL (0x65645f6d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x72000000),  // name = nested_member
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x54505f54), 
          ACE_NTOHL (0x6573742f), 
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                    15,
          ACE_NTOHL (0x4e657374), 
          ACE_NTOHL (0x65645365), 
          ACE_NTOHL (0x7175656e), 
          ACE_NTOHL (0x63650000),  // name = NestedSequence
                    CORBA::tk_sequence, // typecode kind
          100, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            84, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              23,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65643a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                            7,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65640000),  // name = Nested
              2, // member count
                            5,
              ACE_NTOHL (0x696e666f), 
              ACE_NTOHL (0x0),  // name = info
                            CORBA::tk_string, 
              0U, // string length
              6,
              ACE_NTOHL (0x696e6465), 
              ACE_NTOHL (0x78000000),  // name = index
                            CORBA::tk_long,


            0U,



      16384U,


};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384 (
    CORBA::tk_struct,
    sizeof (_oc_TP_Test_Complex16384),
    (char *) &_oc_TP_Test_Complex16384,
    0,
    sizeof (TP_Test::Complex16384)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384 =
    &_tc_TAO_tc_TP_Test_Complex16384;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
TP_Test::Complex16384::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Complex16384 *_tao_tmp_pointer =
    ACE_static_cast (Complex16384 *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::QuitMsg &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::QuitMsg>::insert_copy (
      _tao_any,
      TP_Test::QuitMsg::_tao_any_destructor,
      TP_Test::_tc_QuitMsg,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsg *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::QuitMsg>::insert (
      _tao_any,
      TP_Test::QuitMsg::_tao_any_destructor,
      TP_Test::_tc_QuitMsg,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::QuitMsg *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::QuitMsg *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::QuitMsg *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::QuitMsg>::extract (
        _tao_any,
        TP_Test::QuitMsg::_tao_any_destructor,
        TP_Test::_tc_QuitMsg,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes4Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes4Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4Sequence>::insert (
      _tao_any,
      TP_Test::Bytes4Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes4Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4Sequence>::extract (
        _tao_any,
        TP_Test::Bytes4Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes4Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes8Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes8Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8Sequence>::insert (
      _tao_any,
      TP_Test::Bytes8Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes8Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8Sequence>::extract (
        _tao_any,
        TP_Test::Bytes8Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes8Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes16Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes16Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16Sequence>::insert (
      _tao_any,
      TP_Test::Bytes16Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes16Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16Sequence>::extract (
        _tao_any,
        TP_Test::Bytes16Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes16Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes32Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes32Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes32Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32Sequence>::insert (
      _tao_any,
      TP_Test::Bytes32Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes32Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes32Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes32Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes32Sequence>::extract (
        _tao_any,
        TP_Test::Bytes32Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes32Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes64Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes64Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes64Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64Sequence>::insert (
      _tao_any,
      TP_Test::Bytes64Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes64Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes64Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes64Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes64Sequence>::extract (
        _tao_any,
        TP_Test::Bytes64Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes64Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes128Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes128Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes128Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128Sequence>::insert (
      _tao_any,
      TP_Test::Bytes128Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes128Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes128Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes128Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes128Sequence>::extract (
        _tao_any,
        TP_Test::Bytes128Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes128Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes256Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes256Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes256Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256Sequence>::insert (
      _tao_any,
      TP_Test::Bytes256Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes256Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes256Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes256Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes256Sequence>::extract (
        _tao_any,
        TP_Test::Bytes256Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes256Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes512Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes512Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes512Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512Sequence>::insert (
      _tao_any,
      TP_Test::Bytes512Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes512Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes512Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes512Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes512Sequence>::extract (
        _tao_any,
        TP_Test::Bytes512Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes512Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes1024Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes1024Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes1024Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Sequence>::insert (
      _tao_any,
      TP_Test::Bytes1024Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes1024Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes1024Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes1024Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Sequence>::extract (
        _tao_any,
        TP_Test::Bytes1024Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes1024Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes2048Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes2048Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes2048Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Sequence>::insert (
      _tao_any,
      TP_Test::Bytes2048Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes2048Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes2048Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes2048Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Sequence>::extract (
        _tao_any,
        TP_Test::Bytes2048Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes2048Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4096Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes4096Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes4096Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Sequence>::insert (
      _tao_any,
      TP_Test::Bytes4096Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes4096Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4096Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4096Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Sequence>::extract (
        _tao_any,
        TP_Test::Bytes4096Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes4096Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8192Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes8192Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes8192Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Sequence>::insert (
      _tao_any,
      TP_Test::Bytes8192Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes8192Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8192Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8192Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Sequence>::extract (
        _tao_any,
        TP_Test::Bytes8192Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes8192Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16384Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Sequence>::insert_copy (
      _tao_any,
      TP_Test::Bytes16384Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes16384Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Sequence>::insert (
      _tao_any,
      TP_Test::Bytes16384Sequence::_tao_any_destructor,
      TP_Test::_tc_Bytes16384Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16384Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16384Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Sequence>::extract (
        _tao_any,
        TP_Test::Bytes16384Sequence::_tao_any_destructor,
        TP_Test::_tc_Bytes16384Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4>::insert_copy (
      _tao_any,
      TP_Test::Bytes4::_tao_any_destructor,
      TP_Test::_tc_Bytes4,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4>::insert (
      _tao_any,
      TP_Test::Bytes4::_tao_any_destructor,
      TP_Test::_tc_Bytes4,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4>::extract (
        _tao_any,
        TP_Test::Bytes4::_tao_any_destructor,
        TP_Test::_tc_Bytes4,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8>::insert_copy (
      _tao_any,
      TP_Test::Bytes8::_tao_any_destructor,
      TP_Test::_tc_Bytes8,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8>::insert (
      _tao_any,
      TP_Test::Bytes8::_tao_any_destructor,
      TP_Test::_tc_Bytes8,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8>::extract (
        _tao_any,
        TP_Test::Bytes8::_tao_any_destructor,
        TP_Test::_tc_Bytes8,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16>::insert_copy (
      _tao_any,
      TP_Test::Bytes16::_tao_any_destructor,
      TP_Test::_tc_Bytes16,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16>::insert (
      _tao_any,
      TP_Test::Bytes16::_tao_any_destructor,
      TP_Test::_tc_Bytes16,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16>::extract (
        _tao_any,
        TP_Test::Bytes16::_tao_any_destructor,
        TP_Test::_tc_Bytes16,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes32 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32>::insert_copy (
      _tao_any,
      TP_Test::Bytes32::_tao_any_destructor,
      TP_Test::_tc_Bytes32,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32>::insert (
      _tao_any,
      TP_Test::Bytes32::_tao_any_destructor,
      TP_Test::_tc_Bytes32,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes32 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes32 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes32>::extract (
        _tao_any,
        TP_Test::Bytes32::_tao_any_destructor,
        TP_Test::_tc_Bytes32,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes64 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64>::insert_copy (
      _tao_any,
      TP_Test::Bytes64::_tao_any_destructor,
      TP_Test::_tc_Bytes64,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64>::insert (
      _tao_any,
      TP_Test::Bytes64::_tao_any_destructor,
      TP_Test::_tc_Bytes64,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes64 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes64 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes64>::extract (
        _tao_any,
        TP_Test::Bytes64::_tao_any_destructor,
        TP_Test::_tc_Bytes64,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes128 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128>::insert_copy (
      _tao_any,
      TP_Test::Bytes128::_tao_any_destructor,
      TP_Test::_tc_Bytes128,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128>::insert (
      _tao_any,
      TP_Test::Bytes128::_tao_any_destructor,
      TP_Test::_tc_Bytes128,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes128 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes128 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes128>::extract (
        _tao_any,
        TP_Test::Bytes128::_tao_any_destructor,
        TP_Test::_tc_Bytes128,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes256 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256>::insert_copy (
      _tao_any,
      TP_Test::Bytes256::_tao_any_destructor,
      TP_Test::_tc_Bytes256,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256>::insert (
      _tao_any,
      TP_Test::Bytes256::_tao_any_destructor,
      TP_Test::_tc_Bytes256,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes256 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes256 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes256>::extract (
        _tao_any,
        TP_Test::Bytes256::_tao_any_destructor,
        TP_Test::_tc_Bytes256,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes512 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512>::insert_copy (
      _tao_any,
      TP_Test::Bytes512::_tao_any_destructor,
      TP_Test::_tc_Bytes512,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512>::insert (
      _tao_any,
      TP_Test::Bytes512::_tao_any_destructor,
      TP_Test::_tc_Bytes512,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes512 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes512 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes512>::extract (
        _tao_any,
        TP_Test::Bytes512::_tao_any_destructor,
        TP_Test::_tc_Bytes512,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes1024 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024>::insert_copy (
      _tao_any,
      TP_Test::Bytes1024::_tao_any_destructor,
      TP_Test::_tc_Bytes1024,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024>::insert (
      _tao_any,
      TP_Test::Bytes1024::_tao_any_destructor,
      TP_Test::_tc_Bytes1024,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes1024 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes1024 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes1024>::extract (
        _tao_any,
        TP_Test::Bytes1024::_tao_any_destructor,
        TP_Test::_tc_Bytes1024,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes2048 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048>::insert_copy (
      _tao_any,
      TP_Test::Bytes2048::_tao_any_destructor,
      TP_Test::_tc_Bytes2048,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048>::insert (
      _tao_any,
      TP_Test::Bytes2048::_tao_any_destructor,
      TP_Test::_tc_Bytes2048,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes2048 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes2048 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes2048>::extract (
        _tao_any,
        TP_Test::Bytes2048::_tao_any_destructor,
        TP_Test::_tc_Bytes2048,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4096 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096>::insert_copy (
      _tao_any,
      TP_Test::Bytes4096::_tao_any_destructor,
      TP_Test::_tc_Bytes4096,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096>::insert (
      _tao_any,
      TP_Test::Bytes4096::_tao_any_destructor,
      TP_Test::_tc_Bytes4096,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4096 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4096 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4096>::extract (
        _tao_any,
        TP_Test::Bytes4096::_tao_any_destructor,
        TP_Test::_tc_Bytes4096,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8192 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192>::insert_copy (
      _tao_any,
      TP_Test::Bytes8192::_tao_any_destructor,
      TP_Test::_tc_Bytes8192,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192>::insert (
      _tao_any,
      TP_Test::Bytes8192::_tao_any_destructor,
      TP_Test::_tc_Bytes8192,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8192 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8192 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8192>::extract (
        _tao_any,
        TP_Test::Bytes8192::_tao_any_destructor,
        TP_Test::_tc_Bytes8192,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16384 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384>::insert_copy (
      _tao_any,
      TP_Test::Bytes16384::_tao_any_destructor,
      TP_Test::_tc_Bytes16384,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384>::insert (
      _tao_any,
      TP_Test::Bytes16384::_tao_any_destructor,
      TP_Test::_tc_Bytes16384,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16384 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16384 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16384>::extract (
        _tao_any,
        TP_Test::Bytes16384::_tao_any_destructor,
        TP_Test::_tc_Bytes16384,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Nested &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Nested>::insert_copy (
      _tao_any,
      TP_Test::Nested::_tao_any_destructor,
      TP_Test::_tc_Nested,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Nested *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Nested>::insert (
      _tao_any,
      TP_Test::Nested::_tao_any_destructor,
      TP_Test::_tc_Nested,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Nested *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Nested *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Nested *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Nested>::extract (
        _tao_any,
        TP_Test::Nested::_tao_any_destructor,
        TP_Test::_tc_Nested,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::NestedSequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::NestedSequence>::insert_copy (
      _tao_any,
      TP_Test::NestedSequence::_tao_any_destructor,
      TP_Test::_tc_NestedSequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::NestedSequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::NestedSequence>::insert (
      _tao_any,
      TP_Test::NestedSequence::_tao_any_destructor,
      TP_Test::_tc_NestedSequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::NestedSequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::NestedSequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::NestedSequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::NestedSequence>::extract (
        _tao_any,
        TP_Test::NestedSequence::_tao_any_destructor,
        TP_Test::_tc_NestedSequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Outer &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Outer>::insert_copy (
      _tao_any,
      TP_Test::Outer::_tao_any_destructor,
      TP_Test::_tc_Outer,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Outer *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Outer>::insert (
      _tao_any,
      TP_Test::Outer::_tao_any_destructor,
      TP_Test::_tc_Outer,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Outer *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Outer *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Outer *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Outer>::extract (
        _tao_any,
        TP_Test::Outer::_tao_any_destructor,
        TP_Test::_tc_Outer,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex4Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex4Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4Sequence>::insert (
      _tao_any,
      TP_Test::Complex4Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex4Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4Sequence>::extract (
        _tao_any,
        TP_Test::Complex4Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex4Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex8Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex8Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8Sequence>::insert (
      _tao_any,
      TP_Test::Complex8Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex8Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8Sequence>::extract (
        _tao_any,
        TP_Test::Complex8Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex8Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex16Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex16Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16Sequence>::insert (
      _tao_any,
      TP_Test::Complex16Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex16Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16Sequence>::extract (
        _tao_any,
        TP_Test::Complex16Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex16Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex32Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex32Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex32Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32Sequence>::insert (
      _tao_any,
      TP_Test::Complex32Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex32Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex32Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex32Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex32Sequence>::extract (
        _tao_any,
        TP_Test::Complex32Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex32Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex64Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex64Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex64Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64Sequence>::insert (
      _tao_any,
      TP_Test::Complex64Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex64Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex64Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex64Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex64Sequence>::extract (
        _tao_any,
        TP_Test::Complex64Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex64Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex128Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex128Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex128Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128Sequence>::insert (
      _tao_any,
      TP_Test::Complex128Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex128Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex128Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex128Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex128Sequence>::extract (
        _tao_any,
        TP_Test::Complex128Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex128Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex256Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex256Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex256Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256Sequence>::insert (
      _tao_any,
      TP_Test::Complex256Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex256Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex256Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex256Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex256Sequence>::extract (
        _tao_any,
        TP_Test::Complex256Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex256Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex512Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex512Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex512Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512Sequence>::insert (
      _tao_any,
      TP_Test::Complex512Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex512Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex512Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex512Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex512Sequence>::extract (
        _tao_any,
        TP_Test::Complex512Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex512Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex1024Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex1024Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex1024Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024Sequence>::insert (
      _tao_any,
      TP_Test::Complex1024Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex1024Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex1024Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex1024Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex1024Sequence>::extract (
        _tao_any,
        TP_Test::Complex1024Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex1024Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex2048Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex2048Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex2048Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048Sequence>::insert (
      _tao_any,
      TP_Test::Complex2048Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex2048Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex2048Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex2048Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex2048Sequence>::extract (
        _tao_any,
        TP_Test::Complex2048Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex2048Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4096Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex4096Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex4096Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096Sequence>::insert (
      _tao_any,
      TP_Test::Complex4096Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex4096Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4096Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4096Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4096Sequence>::extract (
        _tao_any,
        TP_Test::Complex4096Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex4096Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8192Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex8192Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex8192Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192Sequence>::insert (
      _tao_any,
      TP_Test::Complex8192Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex8192Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8192Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8192Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8192Sequence>::extract (
        _tao_any,
        TP_Test::Complex8192Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex8192Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16384Sequence &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384Sequence>::insert_copy (
      _tao_any,
      TP_Test::Complex16384Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex16384Sequence,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384Sequence *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384Sequence>::insert (
      _tao_any,
      TP_Test::Complex16384Sequence::_tao_any_destructor,
      TP_Test::_tc_Complex16384Sequence,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384Sequence *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16384Sequence *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16384Sequence *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16384Sequence>::extract (
        _tao_any,
        TP_Test::Complex16384Sequence::_tao_any_destructor,
        TP_Test::_tc_Complex16384Sequence,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4>::insert_copy (
      _tao_any,
      TP_Test::Complex4::_tao_any_destructor,
      TP_Test::_tc_Complex4,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4>::insert (
      _tao_any,
      TP_Test::Complex4::_tao_any_destructor,
      TP_Test::_tc_Complex4,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4>::extract (
        _tao_any,
        TP_Test::Complex4::_tao_any_destructor,
        TP_Test::_tc_Complex4,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8>::insert_copy (
      _tao_any,
      TP_Test::Complex8::_tao_any_destructor,
      TP_Test::_tc_Complex8,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8>::insert (
      _tao_any,
      TP_Test::Complex8::_tao_any_destructor,
      TP_Test::_tc_Complex8,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8>::extract (
        _tao_any,
        TP_Test::Complex8::_tao_any_destructor,
        TP_Test::_tc_Complex8,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16>::insert_copy (
      _tao_any,
      TP_Test::Complex16::_tao_any_destructor,
      TP_Test::_tc_Complex16,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16>::insert (
      _tao_any,
      TP_Test::Complex16::_tao_any_destructor,
      TP_Test::_tc_Complex16,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16>::extract (
        _tao_any,
        TP_Test::Complex16::_tao_any_destructor,
        TP_Test::_tc_Complex16,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex32 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32>::insert_copy (
      _tao_any,
      TP_Test::Complex32::_tao_any_destructor,
      TP_Test::_tc_Complex32,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32>::insert (
      _tao_any,
      TP_Test::Complex32::_tao_any_destructor,
      TP_Test::_tc_Complex32,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex32 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex32 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex32>::extract (
        _tao_any,
        TP_Test::Complex32::_tao_any_destructor,
        TP_Test::_tc_Complex32,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex64 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64>::insert_copy (
      _tao_any,
      TP_Test::Complex64::_tao_any_destructor,
      TP_Test::_tc_Complex64,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64>::insert (
      _tao_any,
      TP_Test::Complex64::_tao_any_destructor,
      TP_Test::_tc_Complex64,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex64 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex64 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex64>::extract (
        _tao_any,
        TP_Test::Complex64::_tao_any_destructor,
        TP_Test::_tc_Complex64,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex128 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128>::insert_copy (
      _tao_any,
      TP_Test::Complex128::_tao_any_destructor,
      TP_Test::_tc_Complex128,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128>::insert (
      _tao_any,
      TP_Test::Complex128::_tao_any_destructor,
      TP_Test::_tc_Complex128,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex128 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex128 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex128>::extract (
        _tao_any,
        TP_Test::Complex128::_tao_any_destructor,
        TP_Test::_tc_Complex128,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex256 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256>::insert_copy (
      _tao_any,
      TP_Test::Complex256::_tao_any_destructor,
      TP_Test::_tc_Complex256,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256>::insert (
      _tao_any,
      TP_Test::Complex256::_tao_any_destructor,
      TP_Test::_tc_Complex256,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex256 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex256 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex256>::extract (
        _tao_any,
        TP_Test::Complex256::_tao_any_destructor,
        TP_Test::_tc_Complex256,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex512 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512>::insert_copy (
      _tao_any,
      TP_Test::Complex512::_tao_any_destructor,
      TP_Test::_tc_Complex512,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512>::insert (
      _tao_any,
      TP_Test::Complex512::_tao_any_destructor,
      TP_Test::_tc_Complex512,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex512 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex512 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex512>::extract (
        _tao_any,
        TP_Test::Complex512::_tao_any_destructor,
        TP_Test::_tc_Complex512,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex1024 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024>::insert_copy (
      _tao_any,
      TP_Test::Complex1024::_tao_any_destructor,
      TP_Test::_tc_Complex1024,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024>::insert (
      _tao_any,
      TP_Test::Complex1024::_tao_any_destructor,
      TP_Test::_tc_Complex1024,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex1024 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex1024 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex1024>::extract (
        _tao_any,
        TP_Test::Complex1024::_tao_any_destructor,
        TP_Test::_tc_Complex1024,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex2048 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048>::insert_copy (
      _tao_any,
      TP_Test::Complex2048::_tao_any_destructor,
      TP_Test::_tc_Complex2048,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048>::insert (
      _tao_any,
      TP_Test::Complex2048::_tao_any_destructor,
      TP_Test::_tc_Complex2048,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex2048 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex2048 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex2048>::extract (
        _tao_any,
        TP_Test::Complex2048::_tao_any_destructor,
        TP_Test::_tc_Complex2048,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4096 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096>::insert_copy (
      _tao_any,
      TP_Test::Complex4096::_tao_any_destructor,
      TP_Test::_tc_Complex4096,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096>::insert (
      _tao_any,
      TP_Test::Complex4096::_tao_any_destructor,
      TP_Test::_tc_Complex4096,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4096 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4096 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4096>::extract (
        _tao_any,
        TP_Test::Complex4096::_tao_any_destructor,
        TP_Test::_tc_Complex4096,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8192 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192>::insert_copy (
      _tao_any,
      TP_Test::Complex8192::_tao_any_destructor,
      TP_Test::_tc_Complex8192,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192>::insert (
      _tao_any,
      TP_Test::Complex8192::_tao_any_destructor,
      TP_Test::_tc_Complex8192,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8192 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8192 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8192>::extract (
        _tao_any,
        TP_Test::Complex8192::_tao_any_destructor,
        TP_Test::_tc_Complex8192,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16384 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384>::insert_copy (
      _tao_any,
      TP_Test::Complex16384::_tao_any_destructor,
      TP_Test::_tc_Complex16384,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384>::insert (
      _tao_any,
      TP_Test::Complex16384::_tao_any_destructor,
      TP_Test::_tc_Complex16384,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384 *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16384 *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16384 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16384>::extract (
        _tao_any,
        TP_Test::Complex16384::_tao_any_destructor,
        TP_Test::_tc_Complex16384,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes4Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes4Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes4Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes4Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes4Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes8Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes8Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes8Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes8Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes8Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes16Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes16Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes16Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes16Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes16Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes32Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes32Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes32Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes32Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes32Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes64Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes64Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes64Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes64Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes64Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes128Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes128Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes128Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes128Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes128Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes256Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes256Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes256Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes256Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes256Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes512Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes512Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes512Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes512Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes512Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes1024Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes1024Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes1024Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes1024Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes1024Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes2048Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes2048Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes2048Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes2048Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes2048Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes4096Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes4096Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes4096Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes4096Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes4096Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes8192Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes8192Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes8192Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes8192Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes8192Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes16384Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes16384Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes16384Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes16384Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes16384Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_NestedSequence_CPP_
#define _TAO_CDR_OP_TP_Test_NestedSequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::NestedSequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::NestedSequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_NestedSequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex4Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex4Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex4Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex4Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex4Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex8Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex8Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex8Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex8Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex8Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex16Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex16Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex16Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex16Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex16Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex32Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex32Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex32Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex32Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex32Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex64Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex64Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex64Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex64Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex64Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex128Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex128Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex128Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex128Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex128Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex256Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex256Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex256Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex256Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex256Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex512Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex512Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex512Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex512Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex512Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex1024Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex1024Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex1024Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex1024Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex1024Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex2048Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex2048Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex2048Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex2048Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex2048Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex4096Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex4096Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex4096Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex4096Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex4096Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex8192Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex8192Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex8192Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex8192Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex8192Sequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex16384Sequence_CPP_
#define _TAO_CDR_OP_TP_Test_Complex16384Sequence_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex16384Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex16384Sequence &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      if (_tao_seq_len <= _tao_sequence.maximum ())
        {
          // Set the length of the sequence.
          _tao_sequence.length (_tao_seq_len);
          
          // If length is 0 we return true.
          if (0 >= _tao_seq_len) 
            {
              return 1;
            }
          
          // Retrieve all the elements.
          CORBA::Boolean _tao_marshal_flag = 1;
          
          for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
            {
              _tao_marshal_flag = (strm >> _tao_sequence[i]);
            }
          
          return _tao_marshal_flag;
        
        }
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex16384Sequence_CPP_ */

