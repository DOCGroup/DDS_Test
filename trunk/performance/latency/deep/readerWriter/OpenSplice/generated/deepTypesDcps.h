//******************************************************************
// 
//  Generated by e*ORB IDL to C++ Translator
//  Copyright (c) PrismTech Limited 2006
//  
//  File name: deepTypesDcps.h
//  Source: deepTypesDcps.idl
//  Generated: Fri Mar 30 14:15:43 2007
//  OpenFusion eORB C++ V1.5.0
//  
//  All Rights Reserved
//  
//******************************************************************
#ifndef _DEEPTYPESDCPS_H_
#define _DEEPTYPESDCPS_H_

#undef EORB_NAMESPACE_SUPPORTED
#define EORB_NAMESPACE_SUPPORTED
#include "sacpp_orb_pa.h"
#include "eOrb/DDS.h"
#include "eOrb/idl_c.h"
#include "deepTypes.h"
#include "dds_dcps.h"
#include "dds_dcps_builtintopics.h"

namespace deepTypes
{
struct simpleType;
struct innerStruct;
struct nestedType;
struct arrayType;
struct stringType;

   class simpleTypeTypeSupportInterface;

   typedef simpleTypeTypeSupportInterface * simpleTypeTypeSupportInterface_ptr;
   typedef EORBInterface_var <simpleTypeTypeSupportInterface> simpleTypeTypeSupportInterface_var;
   typedef EORBInterface_out <simpleTypeTypeSupportInterface> simpleTypeTypeSupportInterface_out;


   class simpleTypeDataWriter;

   typedef simpleTypeDataWriter * simpleTypeDataWriter_ptr;
   typedef EORBInterface_var <simpleTypeDataWriter> simpleTypeDataWriter_var;
   typedef EORBInterface_out <simpleTypeDataWriter> simpleTypeDataWriter_out;


   class simpleTypeDataReader;

   typedef simpleTypeDataReader * simpleTypeDataReader_ptr;
   typedef EORBInterface_var <simpleTypeDataReader> simpleTypeDataReader_var;
   typedef EORBInterface_out <simpleTypeDataReader> simpleTypeDataReader_out;


   class nestedTypeTypeSupportInterface;

   typedef nestedTypeTypeSupportInterface * nestedTypeTypeSupportInterface_ptr;
   typedef EORBInterface_var <nestedTypeTypeSupportInterface> nestedTypeTypeSupportInterface_var;
   typedef EORBInterface_out <nestedTypeTypeSupportInterface> nestedTypeTypeSupportInterface_out;


   class nestedTypeDataWriter;

   typedef nestedTypeDataWriter * nestedTypeDataWriter_ptr;
   typedef EORBInterface_var <nestedTypeDataWriter> nestedTypeDataWriter_var;
   typedef EORBInterface_out <nestedTypeDataWriter> nestedTypeDataWriter_out;


   class nestedTypeDataReader;

   typedef nestedTypeDataReader * nestedTypeDataReader_ptr;
   typedef EORBInterface_var <nestedTypeDataReader> nestedTypeDataReader_var;
   typedef EORBInterface_out <nestedTypeDataReader> nestedTypeDataReader_out;


   class arrayTypeTypeSupportInterface;

   typedef arrayTypeTypeSupportInterface * arrayTypeTypeSupportInterface_ptr;
   typedef EORBInterface_var <arrayTypeTypeSupportInterface> arrayTypeTypeSupportInterface_var;
   typedef EORBInterface_out <arrayTypeTypeSupportInterface> arrayTypeTypeSupportInterface_out;


   class arrayTypeDataWriter;

   typedef arrayTypeDataWriter * arrayTypeDataWriter_ptr;
   typedef EORBInterface_var <arrayTypeDataWriter> arrayTypeDataWriter_var;
   typedef EORBInterface_out <arrayTypeDataWriter> arrayTypeDataWriter_out;


   class arrayTypeDataReader;

   typedef arrayTypeDataReader * arrayTypeDataReader_ptr;
   typedef EORBInterface_var <arrayTypeDataReader> arrayTypeDataReader_var;
   typedef EORBInterface_out <arrayTypeDataReader> arrayTypeDataReader_out;


   class stringTypeTypeSupportInterface;

   typedef stringTypeTypeSupportInterface * stringTypeTypeSupportInterface_ptr;
   typedef EORBInterface_var <stringTypeTypeSupportInterface> stringTypeTypeSupportInterface_var;
   typedef EORBInterface_out <stringTypeTypeSupportInterface> stringTypeTypeSupportInterface_out;


   class stringTypeDataWriter;

   typedef stringTypeDataWriter * stringTypeDataWriter_ptr;
   typedef EORBInterface_var <stringTypeDataWriter> stringTypeDataWriter_var;
   typedef EORBInterface_out <stringTypeDataWriter> stringTypeDataWriter_out;


   class stringTypeDataReader;

   typedef stringTypeDataReader * stringTypeDataReader_ptr;
   typedef EORBInterface_var <stringTypeDataReader> stringTypeDataReader_var;
   typedef EORBInterface_out <stringTypeDataReader> stringTypeDataReader_out;

   typedef CORBA::Long _a_deepTypesDcps_CORBA__Long_1_10_slice;
   typedef CORBA::Long _a_deepTypesDcps_CORBA__Long_1_10[10];
   typedef _a_deepTypesDcps_CORBA__Long_1_10 _a_deepTypesDcps_CORBA__Long_1_10_out;
    _a_deepTypesDcps_CORBA__Long_1_10_slice * _a_deepTypesDcps_CORBA__Long_1_10_alloc ();
    void _a_deepTypesDcps_CORBA__Long_1_10_free (_a_deepTypesDcps_CORBA__Long_1_10_slice *);
    void _a_deepTypesDcps_CORBA__Long_1_10_copy (const _a_deepTypesDcps_CORBA__Long_1_10_slice* to,_a_deepTypesDcps_CORBA__Long_1_10_slice* from);
    _a_deepTypesDcps_CORBA__Long_1_10_slice *_a_deepTypesDcps_CORBA__Long_1_10_dup (const _a_deepTypesDcps_CORBA__Long_1_10_slice* to);

   typedef EORBUFLSeq <simpleType> simpleTypeSeq;
   typedef EORBSequence_var <simpleTypeSeq> simpleTypeSeq_var;
   typedef EORBSequence_out <simpleTypeSeq> simpleTypeSeq_out;
   extern CORBA::TypeCode_ptr _tc_simpleTypeSeq;

   class simpleTypeTypeSupportInterface
   :
      virtual public DDS::TypeSupport
   { 
   public:
      typedef simpleTypeTypeSupportInterface_ptr _ptr_type;
      typedef simpleTypeTypeSupportInterface_var _var_type;

      static simpleTypeTypeSupportInterface_ptr _duplicate (simpleTypeTypeSupportInterface_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static simpleTypeTypeSupportInterface_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeTypeSupportInterface_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeTypeSupportInterface_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      simpleTypeTypeSupportInterface_ptr _this () { return this; }

      // User simpleTypeTypeSupportInterface virtuals 
      virtual DDS::ReturnCode_t register_type (DDS::DomainParticipant_ptr participant, const CORBA::Char* type_name EORB_ENV_ARGN) = 0;
      virtual CORBA::String get_type_name (EORB_ENV_ARG1) = 0;

   protected:
      simpleTypeTypeSupportInterface () {};
      ~simpleTypeTypeSupportInterface () {};
   private:
      simpleTypeTypeSupportInterface (const simpleTypeTypeSupportInterface &) {};
      simpleTypeTypeSupportInterface & operator = (const simpleTypeTypeSupportInterface &);
   };
   extern CORBA::TypeCode_ptr _tc_simpleTypeTypeSupportInterface;


   class simpleTypeDataWriter
   :
      virtual public DDS::DataWriter
   { 
   public:
      typedef simpleTypeDataWriter_ptr _ptr_type;
      typedef simpleTypeDataWriter_var _var_type;

      static simpleTypeDataWriter_ptr _duplicate (simpleTypeDataWriter_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static simpleTypeDataWriter_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeDataWriter_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeDataWriter_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      simpleTypeDataWriter_ptr _this () { return this; }

      // User simpleTypeDataWriter virtuals 
      virtual DDS::InstanceHandle_t register_instance (const simpleType& instance_data EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t register_instance_w_timestamp (const simpleType& instance_data, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance (const simpleType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance_w_timestamp (const simpleType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write (const simpleType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write_w_timestamp (const simpleType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose (const simpleType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose_w_timestamp (const simpleType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (simpleType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;

   protected:
      simpleTypeDataWriter () {};
      ~simpleTypeDataWriter () {};
   private:
      simpleTypeDataWriter (const simpleTypeDataWriter &) {};
      simpleTypeDataWriter & operator = (const simpleTypeDataWriter &);
   };
   extern CORBA::TypeCode_ptr _tc_simpleTypeDataWriter;


   class simpleTypeDataReader
   :
      virtual public DDS::DataReader
   { 
   public:
      typedef simpleTypeDataReader_ptr _ptr_type;
      typedef simpleTypeDataReader_var _var_type;

      static simpleTypeDataReader_ptr _duplicate (simpleTypeDataReader_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static simpleTypeDataReader_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeDataReader_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static simpleTypeDataReader_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      simpleTypeDataReader_ptr _this () { return this; }

      // User simpleTypeDataReader virtuals 
      virtual DDS::ReturnCode_t read (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_w_condition (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_w_condition (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_sample (simpleType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_sample (simpleType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_instance (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_instance (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance_w_condition (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance_w_condition (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t return_loan (simpleTypeSeq& received_data, DDS::SampleInfoSeq& info_seq EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (simpleType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t lookup_instance (const simpleType& instance EORB_ENV_ARGN) = 0;

   protected:
      simpleTypeDataReader () {};
      ~simpleTypeDataReader () {};
   private:
      simpleTypeDataReader (const simpleTypeDataReader &) {};
      simpleTypeDataReader & operator = (const simpleTypeDataReader &);
   };
   extern CORBA::TypeCode_ptr _tc_simpleTypeDataReader;


   typedef EORBUFLSeq <nestedType> nestedTypeSeq;
   typedef EORBSequence_var <nestedTypeSeq> nestedTypeSeq_var;
   typedef EORBSequence_out <nestedTypeSeq> nestedTypeSeq_out;
   extern CORBA::TypeCode_ptr _tc_nestedTypeSeq;

   class nestedTypeTypeSupportInterface
   :
      virtual public DDS::TypeSupport
   { 
   public:
      typedef nestedTypeTypeSupportInterface_ptr _ptr_type;
      typedef nestedTypeTypeSupportInterface_var _var_type;

      static nestedTypeTypeSupportInterface_ptr _duplicate (nestedTypeTypeSupportInterface_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static nestedTypeTypeSupportInterface_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeTypeSupportInterface_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeTypeSupportInterface_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      nestedTypeTypeSupportInterface_ptr _this () { return this; }

      // User nestedTypeTypeSupportInterface virtuals 
      virtual DDS::ReturnCode_t register_type (DDS::DomainParticipant_ptr participant, const CORBA::Char* type_name EORB_ENV_ARGN) = 0;
      virtual CORBA::String get_type_name (EORB_ENV_ARG1) = 0;

   protected:
      nestedTypeTypeSupportInterface () {};
      ~nestedTypeTypeSupportInterface () {};
   private:
      nestedTypeTypeSupportInterface (const nestedTypeTypeSupportInterface &) {};
      nestedTypeTypeSupportInterface & operator = (const nestedTypeTypeSupportInterface &);
   };
   extern CORBA::TypeCode_ptr _tc_nestedTypeTypeSupportInterface;


   class nestedTypeDataWriter
   :
      virtual public DDS::DataWriter
   { 
   public:
      typedef nestedTypeDataWriter_ptr _ptr_type;
      typedef nestedTypeDataWriter_var _var_type;

      static nestedTypeDataWriter_ptr _duplicate (nestedTypeDataWriter_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static nestedTypeDataWriter_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeDataWriter_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeDataWriter_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      nestedTypeDataWriter_ptr _this () { return this; }

      // User nestedTypeDataWriter virtuals 
      virtual DDS::InstanceHandle_t register_instance (const nestedType& instance_data EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t register_instance_w_timestamp (const nestedType& instance_data, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance (const nestedType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance_w_timestamp (const nestedType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write (const nestedType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write_w_timestamp (const nestedType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose (const nestedType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose_w_timestamp (const nestedType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (nestedType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;

   protected:
      nestedTypeDataWriter () {};
      ~nestedTypeDataWriter () {};
   private:
      nestedTypeDataWriter (const nestedTypeDataWriter &) {};
      nestedTypeDataWriter & operator = (const nestedTypeDataWriter &);
   };
   extern CORBA::TypeCode_ptr _tc_nestedTypeDataWriter;


   class nestedTypeDataReader
   :
      virtual public DDS::DataReader
   { 
   public:
      typedef nestedTypeDataReader_ptr _ptr_type;
      typedef nestedTypeDataReader_var _var_type;

      static nestedTypeDataReader_ptr _duplicate (nestedTypeDataReader_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static nestedTypeDataReader_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeDataReader_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static nestedTypeDataReader_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      nestedTypeDataReader_ptr _this () { return this; }

      // User nestedTypeDataReader virtuals 
      virtual DDS::ReturnCode_t read (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_w_condition (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_w_condition (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_sample (nestedType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_sample (nestedType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_instance (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_instance (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance_w_condition (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance_w_condition (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t return_loan (nestedTypeSeq& received_data, DDS::SampleInfoSeq& info_seq EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (nestedType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t lookup_instance (const nestedType& instance EORB_ENV_ARGN) = 0;

   protected:
      nestedTypeDataReader () {};
      ~nestedTypeDataReader () {};
   private:
      nestedTypeDataReader (const nestedTypeDataReader &) {};
      nestedTypeDataReader & operator = (const nestedTypeDataReader &);
   };
   extern CORBA::TypeCode_ptr _tc_nestedTypeDataReader;


   typedef EORBUFLSeq <arrayType> arrayTypeSeq;
   typedef EORBSequence_var <arrayTypeSeq> arrayTypeSeq_var;
   typedef EORBSequence_out <arrayTypeSeq> arrayTypeSeq_out;
   extern CORBA::TypeCode_ptr _tc_arrayTypeSeq;

   class arrayTypeTypeSupportInterface
   :
      virtual public DDS::TypeSupport
   { 
   public:
      typedef arrayTypeTypeSupportInterface_ptr _ptr_type;
      typedef arrayTypeTypeSupportInterface_var _var_type;

      static arrayTypeTypeSupportInterface_ptr _duplicate (arrayTypeTypeSupportInterface_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static arrayTypeTypeSupportInterface_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeTypeSupportInterface_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeTypeSupportInterface_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      arrayTypeTypeSupportInterface_ptr _this () { return this; }

      // User arrayTypeTypeSupportInterface virtuals 
      virtual DDS::ReturnCode_t register_type (DDS::DomainParticipant_ptr participant, const CORBA::Char* type_name EORB_ENV_ARGN) = 0;
      virtual CORBA::String get_type_name (EORB_ENV_ARG1) = 0;

   protected:
      arrayTypeTypeSupportInterface () {};
      ~arrayTypeTypeSupportInterface () {};
   private:
      arrayTypeTypeSupportInterface (const arrayTypeTypeSupportInterface &) {};
      arrayTypeTypeSupportInterface & operator = (const arrayTypeTypeSupportInterface &);
   };
   extern CORBA::TypeCode_ptr _tc_arrayTypeTypeSupportInterface;


   class arrayTypeDataWriter
   :
      virtual public DDS::DataWriter
   { 
   public:
      typedef arrayTypeDataWriter_ptr _ptr_type;
      typedef arrayTypeDataWriter_var _var_type;

      static arrayTypeDataWriter_ptr _duplicate (arrayTypeDataWriter_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static arrayTypeDataWriter_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeDataWriter_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeDataWriter_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      arrayTypeDataWriter_ptr _this () { return this; }

      // User arrayTypeDataWriter virtuals 
      virtual DDS::InstanceHandle_t register_instance (const arrayType& instance_data EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t register_instance_w_timestamp (const arrayType& instance_data, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance (const arrayType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance_w_timestamp (const arrayType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write (const arrayType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write_w_timestamp (const arrayType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose (const arrayType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose_w_timestamp (const arrayType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (arrayType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;

   protected:
      arrayTypeDataWriter () {};
      ~arrayTypeDataWriter () {};
   private:
      arrayTypeDataWriter (const arrayTypeDataWriter &) {};
      arrayTypeDataWriter & operator = (const arrayTypeDataWriter &);
   };
   extern CORBA::TypeCode_ptr _tc_arrayTypeDataWriter;


   class arrayTypeDataReader
   :
      virtual public DDS::DataReader
   { 
   public:
      typedef arrayTypeDataReader_ptr _ptr_type;
      typedef arrayTypeDataReader_var _var_type;

      static arrayTypeDataReader_ptr _duplicate (arrayTypeDataReader_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static arrayTypeDataReader_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeDataReader_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static arrayTypeDataReader_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      arrayTypeDataReader_ptr _this () { return this; }

      // User arrayTypeDataReader virtuals 
      virtual DDS::ReturnCode_t read (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_w_condition (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_w_condition (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_sample (arrayType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_sample (arrayType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_instance (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_instance (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance_w_condition (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance_w_condition (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t return_loan (arrayTypeSeq& received_data, DDS::SampleInfoSeq& info_seq EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (arrayType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t lookup_instance (const arrayType& instance EORB_ENV_ARGN) = 0;

   protected:
      arrayTypeDataReader () {};
      ~arrayTypeDataReader () {};
   private:
      arrayTypeDataReader (const arrayTypeDataReader &) {};
      arrayTypeDataReader & operator = (const arrayTypeDataReader &);
   };
   extern CORBA::TypeCode_ptr _tc_arrayTypeDataReader;


   typedef EORBUVLSeq <stringType> stringTypeSeq;
   typedef EORBSequence_var <stringTypeSeq> stringTypeSeq_var;
   typedef EORBSequence_out <stringTypeSeq> stringTypeSeq_out;
   extern CORBA::TypeCode_ptr _tc_stringTypeSeq;

   class stringTypeTypeSupportInterface
   :
      virtual public DDS::TypeSupport
   { 
   public:
      typedef stringTypeTypeSupportInterface_ptr _ptr_type;
      typedef stringTypeTypeSupportInterface_var _var_type;

      static stringTypeTypeSupportInterface_ptr _duplicate (stringTypeTypeSupportInterface_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static stringTypeTypeSupportInterface_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeTypeSupportInterface_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeTypeSupportInterface_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      stringTypeTypeSupportInterface_ptr _this () { return this; }

      // User stringTypeTypeSupportInterface virtuals 
      virtual DDS::ReturnCode_t register_type (DDS::DomainParticipant_ptr participant, const CORBA::Char* type_name EORB_ENV_ARGN) = 0;
      virtual CORBA::String get_type_name (EORB_ENV_ARG1) = 0;

   protected:
      stringTypeTypeSupportInterface () {};
      ~stringTypeTypeSupportInterface () {};
   private:
      stringTypeTypeSupportInterface (const stringTypeTypeSupportInterface &) {};
      stringTypeTypeSupportInterface & operator = (const stringTypeTypeSupportInterface &);
   };
   extern CORBA::TypeCode_ptr _tc_stringTypeTypeSupportInterface;


   class stringTypeDataWriter
   :
      virtual public DDS::DataWriter
   { 
   public:
      typedef stringTypeDataWriter_ptr _ptr_type;
      typedef stringTypeDataWriter_var _var_type;

      static stringTypeDataWriter_ptr _duplicate (stringTypeDataWriter_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static stringTypeDataWriter_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeDataWriter_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeDataWriter_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      stringTypeDataWriter_ptr _this () { return this; }

      // User stringTypeDataWriter virtuals 
      virtual DDS::InstanceHandle_t register_instance (const stringType& instance_data EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t register_instance_w_timestamp (const stringType& instance_data, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance (const stringType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t unregister_instance_w_timestamp (const stringType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write (const stringType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t write_w_timestamp (const stringType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose (const stringType& instance_data, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t dispose_w_timestamp (const stringType& instance_data, DDS::InstanceHandle_t handle, const DDS::Time_t& source_timestamp EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (stringType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;

   protected:
      stringTypeDataWriter () {};
      ~stringTypeDataWriter () {};
   private:
      stringTypeDataWriter (const stringTypeDataWriter &) {};
      stringTypeDataWriter & operator = (const stringTypeDataWriter &);
   };
   extern CORBA::TypeCode_ptr _tc_stringTypeDataWriter;


   class stringTypeDataReader
   :
      virtual public DDS::DataReader
   { 
   public:
      typedef stringTypeDataReader_ptr _ptr_type;
      typedef stringTypeDataReader_var _var_type;

      static stringTypeDataReader_ptr _duplicate (stringTypeDataReader_ptr obj);
      CORBA::Boolean  _local_is_a (const char *repositryID EORB_ENV_ARGN);
      
      static stringTypeDataReader_ptr _narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeDataReader_ptr _unchecked_narrow (CORBA::Object_ptr obj EORB_ENV_ARGN);
      static stringTypeDataReader_ptr _nil () { return nil; }
      static char * _local_rep_id_string;
      stringTypeDataReader_ptr _this () { return this; }

      // User stringTypeDataReader virtuals 
      virtual DDS::ReturnCode_t read (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_w_condition (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_w_condition (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_sample (stringType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_sample (stringType& received_data, DDS::SampleInfo& sample_info EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_instance (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_instance (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t read_next_instance_w_condition (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t take_next_instance_w_condition (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples, DDS::InstanceHandle_t a_handle, DDS::ReadCondition_ptr a_condition EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t return_loan (stringTypeSeq& received_data, DDS::SampleInfoSeq& info_seq EORB_ENV_ARGN) = 0;
      virtual DDS::ReturnCode_t get_key_value (stringType& key_holder, DDS::InstanceHandle_t handle EORB_ENV_ARGN) = 0;
      virtual DDS::InstanceHandle_t lookup_instance (const stringType& instance EORB_ENV_ARGN) = 0;

   protected:
      stringTypeDataReader () {};
      ~stringTypeDataReader () {};
   private:
      stringTypeDataReader (const stringTypeDataReader &) {};
      stringTypeDataReader & operator = (const stringTypeDataReader &);
   };
   extern CORBA::TypeCode_ptr _tc_stringTypeDataReader;


}




#endif 
