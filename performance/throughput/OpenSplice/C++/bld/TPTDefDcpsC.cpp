// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:323


#include "TPTDefDcpsC.h"
#include "tao/Typecode.h"
#include "tao/Any_Impl_T.h"
#include "tao/Any_Dual_Impl_T.h"
#include "ace/OS_NS_string.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "TPTDefDcpsC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:65

// Arg traits specializations.
namespace TAO
{
}


// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_QUITMSGSEQ_CS_)
#define _TP_TEST_QUITMSGSEQ_CS_

TP_Test::QuitMsgSeq::QuitMsgSeq (void)
{}

TP_Test::QuitMsgSeq::QuitMsgSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::QuitMsg
      >
    (max)
{}

TP_Test::QuitMsgSeq::QuitMsgSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::QuitMsg * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::QuitMsg
      >
    (max, length, buffer, release)
{}

TP_Test::QuitMsgSeq::QuitMsgSeq (
    const QuitMsgSeq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::QuitMsg
      >
    (seq)
{}

TP_Test::QuitMsgSeq::~QuitMsgSeq (void)
{}

void TP_Test::QuitMsgSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  QuitMsgSeq * _tao_tmp_pointer =
    ACE_static_cast (QuitMsgSeq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_QuitMsgSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736753), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/QuitMsgSeq:1.0
    11,
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736753), 
  ACE_NTOHL (0x65710000),  // name = QuitMsgSeq
    CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      24,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x51756974), 
      ACE_NTOHL (0x4d73673a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/QuitMsg:1.0
            8,
      ACE_NTOHL (0x51756974), 
      ACE_NTOHL (0x4d736700),  // name = QuitMsg
      1, // member count
            5,
      ACE_NTOHL (0x71756974), 
      ACE_NTOHL (0x0),  // name = quit
            CORBA::tk_boolean,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_QuitMsgSeq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_QuitMsgSeq),
    (char *) &_oc_TP_Test_QuitMsgSeq,
    0,
    sizeof (TP_Test::QuitMsgSeq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_QuitMsgSeq =
    &_tc_TAO_tc_TP_Test_QuitMsgSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::QuitMsgTypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgTypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::QuitMsgTypeSupportInterface>::tao_duplicate (
    TP_Test::QuitMsgTypeSupportInterface_ptr p
  )
{
  return TP_Test::QuitMsgTypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::QuitMsgTypeSupportInterface>::tao_release (
    TP_Test::QuitMsgTypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgTypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::QuitMsgTypeSupportInterface>::tao_nil (void)
{
  return TP_Test::QuitMsgTypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::QuitMsgTypeSupportInterface>::tao_marshal (
    TP_Test::QuitMsgTypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_QuitMsgTypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::QuitMsgTypeSupportInterface::QuitMsgTypeSupportInterface (void)
{}

TP_Test::QuitMsgTypeSupportInterface::~QuitMsgTypeSupportInterface (void)
{}

void 
TP_Test::QuitMsgTypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  QuitMsgTypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (QuitMsgTypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::QuitMsgTypeSupportInterface_ptr
TP_Test::QuitMsgTypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgTypeSupportInterface::_nil ();
    }
  
  QuitMsgTypeSupportInterface_ptr proxy =
    dynamic_cast<QuitMsgTypeSupportInterface_ptr> (_tao_objref);
  
  return QuitMsgTypeSupportInterface::_duplicate (proxy);
}

TP_Test::QuitMsgTypeSupportInterface_ptr
TP_Test::QuitMsgTypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgTypeSupportInterface::_nil ();
    }
  
  QuitMsgTypeSupportInterface_ptr proxy =
    dynamic_cast<QuitMsgTypeSupportInterface_ptr> (_tao_objref);
  
  return QuitMsgTypeSupportInterface::_duplicate (proxy);
}

TP_Test::QuitMsgTypeSupportInterface_ptr
TP_Test::QuitMsgTypeSupportInterface::_duplicate (QuitMsgTypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::QuitMsgTypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/QuitMsgTypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::QuitMsgTypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/QuitMsgTypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::QuitMsgTypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_QuitMsgTypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736754), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/QuitMsgTypeSupportInterface:1.0
    28,
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736754), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = QuitMsgTypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_QuitMsgTypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_QuitMsgTypeSupportInterface),
    (char *) &_oc_TP_Test_QuitMsgTypeSupportInterface,
    0,
    sizeof (TP_Test::QuitMsgTypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_QuitMsgTypeSupportInterface =
    &_tc_TAO_tc_TP_Test_QuitMsgTypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::QuitMsgDataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgDataWriter_ptr
TAO::Objref_Traits<TP_Test::QuitMsgDataWriter>::tao_duplicate (
    TP_Test::QuitMsgDataWriter_ptr p
  )
{
  return TP_Test::QuitMsgDataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::QuitMsgDataWriter>::tao_release (
    TP_Test::QuitMsgDataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgDataWriter_ptr
TAO::Objref_Traits<TP_Test::QuitMsgDataWriter>::tao_nil (void)
{
  return TP_Test::QuitMsgDataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::QuitMsgDataWriter>::tao_marshal (
    TP_Test::QuitMsgDataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_QuitMsgDataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::QuitMsgDataWriter::QuitMsgDataWriter (void)
{}

TP_Test::QuitMsgDataWriter::~QuitMsgDataWriter (void)
{}

void 
TP_Test::QuitMsgDataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  QuitMsgDataWriter *_tao_tmp_pointer =
    ACE_static_cast (QuitMsgDataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::QuitMsgDataWriter_ptr
TP_Test::QuitMsgDataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgDataWriter::_nil ();
    }
  
  QuitMsgDataWriter_ptr proxy =
    dynamic_cast<QuitMsgDataWriter_ptr> (_tao_objref);
  
  return QuitMsgDataWriter::_duplicate (proxy);
}

TP_Test::QuitMsgDataWriter_ptr
TP_Test::QuitMsgDataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgDataWriter::_nil ();
    }
  
  QuitMsgDataWriter_ptr proxy =
    dynamic_cast<QuitMsgDataWriter_ptr> (_tao_objref);
  
  return QuitMsgDataWriter::_duplicate (proxy);
}

TP_Test::QuitMsgDataWriter_ptr
TP_Test::QuitMsgDataWriter::_duplicate (QuitMsgDataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::QuitMsgDataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/QuitMsgDataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::QuitMsgDataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/QuitMsgDataWriter:1.0";
}

CORBA::Boolean
TP_Test::QuitMsgDataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_QuitMsgDataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736744), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/QuitMsgDataWriter:1.0
    18,
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736744), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = QuitMsgDataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_QuitMsgDataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_QuitMsgDataWriter),
    (char *) &_oc_TP_Test_QuitMsgDataWriter,
    0,
    sizeof (TP_Test::QuitMsgDataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_QuitMsgDataWriter =
    &_tc_TAO_tc_TP_Test_QuitMsgDataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::QuitMsgDataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgDataReader_ptr
TAO::Objref_Traits<TP_Test::QuitMsgDataReader>::tao_duplicate (
    TP_Test::QuitMsgDataReader_ptr p
  )
{
  return TP_Test::QuitMsgDataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::QuitMsgDataReader>::tao_release (
    TP_Test::QuitMsgDataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::QuitMsgDataReader_ptr
TAO::Objref_Traits<TP_Test::QuitMsgDataReader>::tao_nil (void)
{
  return TP_Test::QuitMsgDataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::QuitMsgDataReader>::tao_marshal (
    TP_Test::QuitMsgDataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_QuitMsgDataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::QuitMsgDataReader::QuitMsgDataReader (void)
{}

TP_Test::QuitMsgDataReader::~QuitMsgDataReader (void)
{}

void 
TP_Test::QuitMsgDataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  QuitMsgDataReader *_tao_tmp_pointer =
    ACE_static_cast (QuitMsgDataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::QuitMsgDataReader_ptr
TP_Test::QuitMsgDataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgDataReader::_nil ();
    }
  
  QuitMsgDataReader_ptr proxy =
    dynamic_cast<QuitMsgDataReader_ptr> (_tao_objref);
  
  return QuitMsgDataReader::_duplicate (proxy);
}

TP_Test::QuitMsgDataReader_ptr
TP_Test::QuitMsgDataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return QuitMsgDataReader::_nil ();
    }
  
  QuitMsgDataReader_ptr proxy =
    dynamic_cast<QuitMsgDataReader_ptr> (_tao_objref);
  
  return QuitMsgDataReader::_duplicate (proxy);
}

TP_Test::QuitMsgDataReader_ptr
TP_Test::QuitMsgDataReader::_duplicate (QuitMsgDataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::QuitMsgDataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/QuitMsgDataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::QuitMsgDataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/QuitMsgDataReader:1.0";
}

CORBA::Boolean
TP_Test::QuitMsgDataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_QuitMsgDataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736744), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/QuitMsgDataReader:1.0
    18,
  ACE_NTOHL (0x51756974), 
  ACE_NTOHL (0x4d736744), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = QuitMsgDataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_QuitMsgDataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_QuitMsgDataReader),
    (char *) &_oc_TP_Test_QuitMsgDataReader,
    0,
    sizeof (TP_Test::QuitMsgDataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_QuitMsgDataReader =
    &_tc_TAO_tc_TP_Test_QuitMsgDataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES4SEQ_CS_)
#define _TP_TEST_BYTES4SEQ_CS_

TP_Test::Bytes4Seq::Bytes4Seq (void)
{}

TP_Test::Bytes4Seq::Bytes4Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4
      >
    (max)
{}

TP_Test::Bytes4Seq::Bytes4Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes4 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes4Seq::Bytes4Seq (
    const Bytes4Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4
      >
    (seq)
{}

TP_Test::Bytes4Seq::~Bytes4Seq (void)
{}

void TP_Test::Bytes4Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes4Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes4Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4Seq:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345365), 
  ACE_NTOHL (0x71000000),  // name = Bytes4Seq
    CORBA::tk_sequence, // typecode kind
  184, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    168, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      23,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73343a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4:1.0
            7,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73340000),  // name = Bytes4
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73345365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4Sequence:1.0
                15,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73345365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Bytes4Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          4U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes4Seq),
    (char *) &_oc_TP_Test_Bytes4Seq,
    0,
    sizeof (TP_Test::Bytes4Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4Seq =
    &_tc_TAO_tc_TP_Test_Bytes4Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes4TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes4TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes4TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4TypeSupportInterface>::tao_release (
    TP_Test::Bytes4TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes4TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes4TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes4TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4TypeSupportInterface::Bytes4TypeSupportInterface (void)
{}

TP_Test::Bytes4TypeSupportInterface::~Bytes4TypeSupportInterface (void)
{}

void 
TP_Test::Bytes4TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes4TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4TypeSupportInterface_ptr
TP_Test::Bytes4TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4TypeSupportInterface::_nil ();
    }
  
  Bytes4TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes4TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes4TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes4TypeSupportInterface_ptr
TP_Test::Bytes4TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4TypeSupportInterface::_nil ();
    }
  
  Bytes4TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes4TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes4TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes4TypeSupportInterface_ptr
TP_Test::Bytes4TypeSupportInterface::_duplicate (Bytes4TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes4TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes4TypeSupportInterface:1.0
    27,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73345479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Bytes4TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes4TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes4TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes4TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes4DataWriter>::tao_duplicate (
    TP_Test::Bytes4DataWriter_ptr p
  )
{
  return TP_Test::Bytes4DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4DataWriter>::tao_release (
    TP_Test::Bytes4DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes4DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes4DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4DataWriter>::tao_marshal (
    TP_Test::Bytes4DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4DataWriter::Bytes4DataWriter (void)
{}

TP_Test::Bytes4DataWriter::~Bytes4DataWriter (void)
{}

void 
TP_Test::Bytes4DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes4DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4DataWriter_ptr
TP_Test::Bytes4DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4DataWriter::_nil ();
    }
  
  Bytes4DataWriter_ptr proxy =
    dynamic_cast<Bytes4DataWriter_ptr> (_tao_objref);
  
  return Bytes4DataWriter::_duplicate (proxy);
}

TP_Test::Bytes4DataWriter_ptr
TP_Test::Bytes4DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4DataWriter::_nil ();
    }
  
  Bytes4DataWriter_ptr proxy =
    dynamic_cast<Bytes4DataWriter_ptr> (_tao_objref);
  
  return Bytes4DataWriter::_duplicate (proxy);
}

TP_Test::Bytes4DataWriter_ptr
TP_Test::Bytes4DataWriter::_duplicate (Bytes4DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes4DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73344461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes4DataWriter:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73344461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Bytes4DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4DataWriter),
    (char *) &_oc_TP_Test_Bytes4DataWriter,
    0,
    sizeof (TP_Test::Bytes4DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes4DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes4DataReader>::tao_duplicate (
    TP_Test::Bytes4DataReader_ptr p
  )
{
  return TP_Test::Bytes4DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4DataReader>::tao_release (
    TP_Test::Bytes4DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes4DataReader>::tao_nil (void)
{
  return TP_Test::Bytes4DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4DataReader>::tao_marshal (
    TP_Test::Bytes4DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4DataReader::Bytes4DataReader (void)
{}

TP_Test::Bytes4DataReader::~Bytes4DataReader (void)
{}

void 
TP_Test::Bytes4DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes4DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4DataReader_ptr
TP_Test::Bytes4DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4DataReader::_nil ();
    }
  
  Bytes4DataReader_ptr proxy =
    dynamic_cast<Bytes4DataReader_ptr> (_tao_objref);
  
  return Bytes4DataReader::_duplicate (proxy);
}

TP_Test::Bytes4DataReader_ptr
TP_Test::Bytes4DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4DataReader::_nil ();
    }
  
  Bytes4DataReader_ptr proxy =
    dynamic_cast<Bytes4DataReader_ptr> (_tao_objref);
  
  return Bytes4DataReader::_duplicate (proxy);
}

TP_Test::Bytes4DataReader_ptr
TP_Test::Bytes4DataReader::_duplicate (Bytes4DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes4DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73344461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes4DataReader:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73344461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Bytes4DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4DataReader),
    (char *) &_oc_TP_Test_Bytes4DataReader,
    0,
    sizeof (TP_Test::Bytes4DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4DataReader =
    &_tc_TAO_tc_TP_Test_Bytes4DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES8SEQ_CS_)
#define _TP_TEST_BYTES8SEQ_CS_

TP_Test::Bytes8Seq::Bytes8Seq (void)
{}

TP_Test::Bytes8Seq::Bytes8Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8
      >
    (max)
{}

TP_Test::Bytes8Seq::Bytes8Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes8 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes8Seq::Bytes8Seq (
    const Bytes8Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8
      >
    (seq)
{}

TP_Test::Bytes8Seq::~Bytes8Seq (void)
{}

void TP_Test::Bytes8Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes8Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes8Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8Seq:1.0
    10,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385365), 
  ACE_NTOHL (0x71000000),  // name = Bytes8Seq
    CORBA::tk_sequence, // typecode kind
  184, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    168, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      23,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73383a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8:1.0
            7,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73380000),  // name = Bytes8
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73385365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8Sequence:1.0
                15,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73385365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Bytes8Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          8U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes8Seq),
    (char *) &_oc_TP_Test_Bytes8Seq,
    0,
    sizeof (TP_Test::Bytes8Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8Seq =
    &_tc_TAO_tc_TP_Test_Bytes8Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes8TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes8TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes8TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8TypeSupportInterface>::tao_release (
    TP_Test::Bytes8TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes8TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes8TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes8TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8TypeSupportInterface::Bytes8TypeSupportInterface (void)
{}

TP_Test::Bytes8TypeSupportInterface::~Bytes8TypeSupportInterface (void)
{}

void 
TP_Test::Bytes8TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes8TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8TypeSupportInterface_ptr
TP_Test::Bytes8TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8TypeSupportInterface::_nil ();
    }
  
  Bytes8TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes8TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes8TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes8TypeSupportInterface_ptr
TP_Test::Bytes8TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8TypeSupportInterface::_nil ();
    }
  
  Bytes8TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes8TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes8TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes8TypeSupportInterface_ptr
TP_Test::Bytes8TypeSupportInterface::_duplicate (Bytes8TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes8TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes8TypeSupportInterface:1.0
    27,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73385479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Bytes8TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes8TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes8TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes8TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes8DataWriter>::tao_duplicate (
    TP_Test::Bytes8DataWriter_ptr p
  )
{
  return TP_Test::Bytes8DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8DataWriter>::tao_release (
    TP_Test::Bytes8DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes8DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes8DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8DataWriter>::tao_marshal (
    TP_Test::Bytes8DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8DataWriter::Bytes8DataWriter (void)
{}

TP_Test::Bytes8DataWriter::~Bytes8DataWriter (void)
{}

void 
TP_Test::Bytes8DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes8DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8DataWriter_ptr
TP_Test::Bytes8DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8DataWriter::_nil ();
    }
  
  Bytes8DataWriter_ptr proxy =
    dynamic_cast<Bytes8DataWriter_ptr> (_tao_objref);
  
  return Bytes8DataWriter::_duplicate (proxy);
}

TP_Test::Bytes8DataWriter_ptr
TP_Test::Bytes8DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8DataWriter::_nil ();
    }
  
  Bytes8DataWriter_ptr proxy =
    dynamic_cast<Bytes8DataWriter_ptr> (_tao_objref);
  
  return Bytes8DataWriter::_duplicate (proxy);
}

TP_Test::Bytes8DataWriter_ptr
TP_Test::Bytes8DataWriter::_duplicate (Bytes8DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes8DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73384461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes8DataWriter:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73384461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Bytes8DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8DataWriter),
    (char *) &_oc_TP_Test_Bytes8DataWriter,
    0,
    sizeof (TP_Test::Bytes8DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes8DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes8DataReader>::tao_duplicate (
    TP_Test::Bytes8DataReader_ptr p
  )
{
  return TP_Test::Bytes8DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8DataReader>::tao_release (
    TP_Test::Bytes8DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes8DataReader>::tao_nil (void)
{
  return TP_Test::Bytes8DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8DataReader>::tao_marshal (
    TP_Test::Bytes8DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8DataReader::Bytes8DataReader (void)
{}

TP_Test::Bytes8DataReader::~Bytes8DataReader (void)
{}

void 
TP_Test::Bytes8DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes8DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8DataReader_ptr
TP_Test::Bytes8DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8DataReader::_nil ();
    }
  
  Bytes8DataReader_ptr proxy =
    dynamic_cast<Bytes8DataReader_ptr> (_tao_objref);
  
  return Bytes8DataReader::_duplicate (proxy);
}

TP_Test::Bytes8DataReader_ptr
TP_Test::Bytes8DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8DataReader::_nil ();
    }
  
  Bytes8DataReader_ptr proxy =
    dynamic_cast<Bytes8DataReader_ptr> (_tao_objref);
  
  return Bytes8DataReader::_duplicate (proxy);
}

TP_Test::Bytes8DataReader_ptr
TP_Test::Bytes8DataReader::_duplicate (Bytes8DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes8DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73384461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes8DataReader:1.0
    17,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73384461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Bytes8DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8DataReader),
    (char *) &_oc_TP_Test_Bytes8DataReader,
    0,
    sizeof (TP_Test::Bytes8DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8DataReader =
    &_tc_TAO_tc_TP_Test_Bytes8DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES16SEQ_CS_)
#define _TP_TEST_BYTES16SEQ_CS_

TP_Test::Bytes16Seq::Bytes16Seq (void)
{}

TP_Test::Bytes16Seq::Bytes16Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16
      >
    (max)
{}

TP_Test::Bytes16Seq::Bytes16Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes16 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes16Seq::Bytes16Seq (
    const Bytes16Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16
      >
    (seq)
{}

TP_Test::Bytes16Seq::~Bytes16Seq (void)
{}

void TP_Test::Bytes16Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes16Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes16Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16Seq:1.0
    11,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313653), 
  ACE_NTOHL (0x65710000),  // name = Bytes16Seq
    CORBA::tk_sequence, // typecode kind
  184, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    168, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      24,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x7331363a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16:1.0
            8,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313600),  // name = Bytes16
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313653), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16Sequence:1.0
                16,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313653), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Bytes16Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          16U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes16Seq),
    (char *) &_oc_TP_Test_Bytes16Seq,
    0,
    sizeof (TP_Test::Bytes16Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16Seq =
    &_tc_TAO_tc_TP_Test_Bytes16Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes16TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes16TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes16TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16TypeSupportInterface>::tao_release (
    TP_Test::Bytes16TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes16TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes16TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes16TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16TypeSupportInterface::Bytes16TypeSupportInterface (void)
{}

TP_Test::Bytes16TypeSupportInterface::~Bytes16TypeSupportInterface (void)
{}

void 
TP_Test::Bytes16TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes16TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16TypeSupportInterface_ptr
TP_Test::Bytes16TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16TypeSupportInterface::_nil ();
    }
  
  Bytes16TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes16TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes16TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes16TypeSupportInterface_ptr
TP_Test::Bytes16TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16TypeSupportInterface::_nil ();
    }
  
  Bytes16TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes16TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes16TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes16TypeSupportInterface_ptr
TP_Test::Bytes16TypeSupportInterface::_duplicate (Bytes16TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes16TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313654), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes16TypeSupportInterface:1.0
    28,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313654), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Bytes16TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes16TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes16TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes16TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes16DataWriter>::tao_duplicate (
    TP_Test::Bytes16DataWriter_ptr p
  )
{
  return TP_Test::Bytes16DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16DataWriter>::tao_release (
    TP_Test::Bytes16DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes16DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes16DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16DataWriter>::tao_marshal (
    TP_Test::Bytes16DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16DataWriter::Bytes16DataWriter (void)
{}

TP_Test::Bytes16DataWriter::~Bytes16DataWriter (void)
{}

void 
TP_Test::Bytes16DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes16DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16DataWriter_ptr
TP_Test::Bytes16DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16DataWriter::_nil ();
    }
  
  Bytes16DataWriter_ptr proxy =
    dynamic_cast<Bytes16DataWriter_ptr> (_tao_objref);
  
  return Bytes16DataWriter::_duplicate (proxy);
}

TP_Test::Bytes16DataWriter_ptr
TP_Test::Bytes16DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16DataWriter::_nil ();
    }
  
  Bytes16DataWriter_ptr proxy =
    dynamic_cast<Bytes16DataWriter_ptr> (_tao_objref);
  
  return Bytes16DataWriter::_duplicate (proxy);
}

TP_Test::Bytes16DataWriter_ptr
TP_Test::Bytes16DataWriter::_duplicate (Bytes16DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes16DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313644), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes16DataWriter:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313644), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Bytes16DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16DataWriter),
    (char *) &_oc_TP_Test_Bytes16DataWriter,
    0,
    sizeof (TP_Test::Bytes16DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes16DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes16DataReader>::tao_duplicate (
    TP_Test::Bytes16DataReader_ptr p
  )
{
  return TP_Test::Bytes16DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16DataReader>::tao_release (
    TP_Test::Bytes16DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes16DataReader>::tao_nil (void)
{
  return TP_Test::Bytes16DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16DataReader>::tao_marshal (
    TP_Test::Bytes16DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16DataReader::Bytes16DataReader (void)
{}

TP_Test::Bytes16DataReader::~Bytes16DataReader (void)
{}

void 
TP_Test::Bytes16DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes16DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16DataReader_ptr
TP_Test::Bytes16DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16DataReader::_nil ();
    }
  
  Bytes16DataReader_ptr proxy =
    dynamic_cast<Bytes16DataReader_ptr> (_tao_objref);
  
  return Bytes16DataReader::_duplicate (proxy);
}

TP_Test::Bytes16DataReader_ptr
TP_Test::Bytes16DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16DataReader::_nil ();
    }
  
  Bytes16DataReader_ptr proxy =
    dynamic_cast<Bytes16DataReader_ptr> (_tao_objref);
  
  return Bytes16DataReader::_duplicate (proxy);
}

TP_Test::Bytes16DataReader_ptr
TP_Test::Bytes16DataReader::_duplicate (Bytes16DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes16DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313644), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes16DataReader:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313644), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Bytes16DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16DataReader),
    (char *) &_oc_TP_Test_Bytes16DataReader,
    0,
    sizeof (TP_Test::Bytes16DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16DataReader =
    &_tc_TAO_tc_TP_Test_Bytes16DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES32SEQ_CS_)
#define _TP_TEST_BYTES32SEQ_CS_

TP_Test::Bytes32Seq::Bytes32Seq (void)
{}

TP_Test::Bytes32Seq::Bytes32Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes32
      >
    (max)
{}

TP_Test::Bytes32Seq::Bytes32Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes32 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes32
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes32Seq::Bytes32Seq (
    const Bytes32Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes32
      >
    (seq)
{}

TP_Test::Bytes32Seq::~Bytes32Seq (void)
{}

void TP_Test::Bytes32Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes32Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes32Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333253), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes32Seq:1.0
    11,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333253), 
  ACE_NTOHL (0x65710000),  // name = Bytes32Seq
    CORBA::tk_sequence, // typecode kind
  184, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    168, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      24,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x7333323a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32:1.0
            8,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73333200),  // name = Bytes32
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73333253), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32Sequence:1.0
                16,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73333253), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Bytes32Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          32U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes32Seq),
    (char *) &_oc_TP_Test_Bytes32Seq,
    0,
    sizeof (TP_Test::Bytes32Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32Seq =
    &_tc_TAO_tc_TP_Test_Bytes32Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes32TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes32TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes32TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes32TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes32TypeSupportInterface>::tao_release (
    TP_Test::Bytes32TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes32TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes32TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes32TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes32TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes32TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes32TypeSupportInterface::Bytes32TypeSupportInterface (void)
{}

TP_Test::Bytes32TypeSupportInterface::~Bytes32TypeSupportInterface (void)
{}

void 
TP_Test::Bytes32TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes32TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes32TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes32TypeSupportInterface_ptr
TP_Test::Bytes32TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32TypeSupportInterface::_nil ();
    }
  
  Bytes32TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes32TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes32TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes32TypeSupportInterface_ptr
TP_Test::Bytes32TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32TypeSupportInterface::_nil ();
    }
  
  Bytes32TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes32TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes32TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes32TypeSupportInterface_ptr
TP_Test::Bytes32TypeSupportInterface::_duplicate (Bytes32TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes32TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes32TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes32TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes32TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes32TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333254), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes32TypeSupportInterface:1.0
    28,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333254), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Bytes32TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes32TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes32TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes32TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes32TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes32DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes32DataWriter>::tao_duplicate (
    TP_Test::Bytes32DataWriter_ptr p
  )
{
  return TP_Test::Bytes32DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes32DataWriter>::tao_release (
    TP_Test::Bytes32DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes32DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes32DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes32DataWriter>::tao_marshal (
    TP_Test::Bytes32DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes32DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes32DataWriter::Bytes32DataWriter (void)
{}

TP_Test::Bytes32DataWriter::~Bytes32DataWriter (void)
{}

void 
TP_Test::Bytes32DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes32DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes32DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes32DataWriter_ptr
TP_Test::Bytes32DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32DataWriter::_nil ();
    }
  
  Bytes32DataWriter_ptr proxy =
    dynamic_cast<Bytes32DataWriter_ptr> (_tao_objref);
  
  return Bytes32DataWriter::_duplicate (proxy);
}

TP_Test::Bytes32DataWriter_ptr
TP_Test::Bytes32DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32DataWriter::_nil ();
    }
  
  Bytes32DataWriter_ptr proxy =
    dynamic_cast<Bytes32DataWriter_ptr> (_tao_objref);
  
  return Bytes32DataWriter::_duplicate (proxy);
}

TP_Test::Bytes32DataWriter_ptr
TP_Test::Bytes32DataWriter::_duplicate (Bytes32DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes32DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes32DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes32DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes32DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes32DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333244), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes32DataWriter:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333244), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Bytes32DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes32DataWriter),
    (char *) &_oc_TP_Test_Bytes32DataWriter,
    0,
    sizeof (TP_Test::Bytes32DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes32DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes32DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes32DataReader>::tao_duplicate (
    TP_Test::Bytes32DataReader_ptr p
  )
{
  return TP_Test::Bytes32DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes32DataReader>::tao_release (
    TP_Test::Bytes32DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes32DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes32DataReader>::tao_nil (void)
{
  return TP_Test::Bytes32DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes32DataReader>::tao_marshal (
    TP_Test::Bytes32DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes32DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes32DataReader::Bytes32DataReader (void)
{}

TP_Test::Bytes32DataReader::~Bytes32DataReader (void)
{}

void 
TP_Test::Bytes32DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes32DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes32DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes32DataReader_ptr
TP_Test::Bytes32DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32DataReader::_nil ();
    }
  
  Bytes32DataReader_ptr proxy =
    dynamic_cast<Bytes32DataReader_ptr> (_tao_objref);
  
  return Bytes32DataReader::_duplicate (proxy);
}

TP_Test::Bytes32DataReader_ptr
TP_Test::Bytes32DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes32DataReader::_nil ();
    }
  
  Bytes32DataReader_ptr proxy =
    dynamic_cast<Bytes32DataReader_ptr> (_tao_objref);
  
  return Bytes32DataReader::_duplicate (proxy);
}

TP_Test::Bytes32DataReader_ptr
TP_Test::Bytes32DataReader::_duplicate (Bytes32DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes32DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes32DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes32DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes32DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes32DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes32DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333244), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes32DataReader:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73333244), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Bytes32DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes32DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes32DataReader),
    (char *) &_oc_TP_Test_Bytes32DataReader,
    0,
    sizeof (TP_Test::Bytes32DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes32DataReader =
    &_tc_TAO_tc_TP_Test_Bytes32DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES64SEQ_CS_)
#define _TP_TEST_BYTES64SEQ_CS_

TP_Test::Bytes64Seq::Bytes64Seq (void)
{}

TP_Test::Bytes64Seq::Bytes64Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes64
      >
    (max)
{}

TP_Test::Bytes64Seq::Bytes64Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes64 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes64
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes64Seq::Bytes64Seq (
    const Bytes64Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes64
      >
    (seq)
{}

TP_Test::Bytes64Seq::~Bytes64Seq (void)
{}

void TP_Test::Bytes64Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes64Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes64Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363453), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes64Seq:1.0
    11,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363453), 
  ACE_NTOHL (0x65710000),  // name = Bytes64Seq
    CORBA::tk_sequence, // typecode kind
  184, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    168, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      24,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x7336343a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64:1.0
            8,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73363400),  // name = Bytes64
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73363453), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64Sequence:1.0
                16,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73363453), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Bytes64Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          64U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes64Seq),
    (char *) &_oc_TP_Test_Bytes64Seq,
    0,
    sizeof (TP_Test::Bytes64Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64Seq =
    &_tc_TAO_tc_TP_Test_Bytes64Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes64TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes64TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes64TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes64TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes64TypeSupportInterface>::tao_release (
    TP_Test::Bytes64TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes64TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes64TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes64TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes64TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes64TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes64TypeSupportInterface::Bytes64TypeSupportInterface (void)
{}

TP_Test::Bytes64TypeSupportInterface::~Bytes64TypeSupportInterface (void)
{}

void 
TP_Test::Bytes64TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes64TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes64TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes64TypeSupportInterface_ptr
TP_Test::Bytes64TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64TypeSupportInterface::_nil ();
    }
  
  Bytes64TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes64TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes64TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes64TypeSupportInterface_ptr
TP_Test::Bytes64TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64TypeSupportInterface::_nil ();
    }
  
  Bytes64TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes64TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes64TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes64TypeSupportInterface_ptr
TP_Test::Bytes64TypeSupportInterface::_duplicate (Bytes64TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes64TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes64TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes64TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes64TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes64TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363454), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes64TypeSupportInterface:1.0
    28,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363454), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Bytes64TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes64TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes64TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes64TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes64TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes64DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes64DataWriter>::tao_duplicate (
    TP_Test::Bytes64DataWriter_ptr p
  )
{
  return TP_Test::Bytes64DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes64DataWriter>::tao_release (
    TP_Test::Bytes64DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes64DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes64DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes64DataWriter>::tao_marshal (
    TP_Test::Bytes64DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes64DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes64DataWriter::Bytes64DataWriter (void)
{}

TP_Test::Bytes64DataWriter::~Bytes64DataWriter (void)
{}

void 
TP_Test::Bytes64DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes64DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes64DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes64DataWriter_ptr
TP_Test::Bytes64DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64DataWriter::_nil ();
    }
  
  Bytes64DataWriter_ptr proxy =
    dynamic_cast<Bytes64DataWriter_ptr> (_tao_objref);
  
  return Bytes64DataWriter::_duplicate (proxy);
}

TP_Test::Bytes64DataWriter_ptr
TP_Test::Bytes64DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64DataWriter::_nil ();
    }
  
  Bytes64DataWriter_ptr proxy =
    dynamic_cast<Bytes64DataWriter_ptr> (_tao_objref);
  
  return Bytes64DataWriter::_duplicate (proxy);
}

TP_Test::Bytes64DataWriter_ptr
TP_Test::Bytes64DataWriter::_duplicate (Bytes64DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes64DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes64DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes64DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes64DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes64DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363444), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes64DataWriter:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363444), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Bytes64DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes64DataWriter),
    (char *) &_oc_TP_Test_Bytes64DataWriter,
    0,
    sizeof (TP_Test::Bytes64DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes64DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes64DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes64DataReader>::tao_duplicate (
    TP_Test::Bytes64DataReader_ptr p
  )
{
  return TP_Test::Bytes64DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes64DataReader>::tao_release (
    TP_Test::Bytes64DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes64DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes64DataReader>::tao_nil (void)
{
  return TP_Test::Bytes64DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes64DataReader>::tao_marshal (
    TP_Test::Bytes64DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes64DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes64DataReader::Bytes64DataReader (void)
{}

TP_Test::Bytes64DataReader::~Bytes64DataReader (void)
{}

void 
TP_Test::Bytes64DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes64DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes64DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes64DataReader_ptr
TP_Test::Bytes64DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64DataReader::_nil ();
    }
  
  Bytes64DataReader_ptr proxy =
    dynamic_cast<Bytes64DataReader_ptr> (_tao_objref);
  
  return Bytes64DataReader::_duplicate (proxy);
}

TP_Test::Bytes64DataReader_ptr
TP_Test::Bytes64DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes64DataReader::_nil ();
    }
  
  Bytes64DataReader_ptr proxy =
    dynamic_cast<Bytes64DataReader_ptr> (_tao_objref);
  
  return Bytes64DataReader::_duplicate (proxy);
}

TP_Test::Bytes64DataReader_ptr
TP_Test::Bytes64DataReader::_duplicate (Bytes64DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes64DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes64DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes64DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes64DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes64DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes64DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363444), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes64DataReader:1.0
    18,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73363444), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Bytes64DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes64DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes64DataReader),
    (char *) &_oc_TP_Test_Bytes64DataReader,
    0,
    sizeof (TP_Test::Bytes64DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes64DataReader =
    &_tc_TAO_tc_TP_Test_Bytes64DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES128SEQ_CS_)
#define _TP_TEST_BYTES128SEQ_CS_

TP_Test::Bytes128Seq::Bytes128Seq (void)
{}

TP_Test::Bytes128Seq::Bytes128Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes128
      >
    (max)
{}

TP_Test::Bytes128Seq::Bytes128Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes128 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes128
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes128Seq::Bytes128Seq (
    const Bytes128Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes128
      >
    (seq)
{}

TP_Test::Bytes128Seq::~Bytes128Seq (void)
{}

void TP_Test::Bytes128Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes128Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes128Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes128Seq:1.0
    12,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x53657100),  // name = Bytes128Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      25,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313238), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128:1.0
            9,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313238), 
      ACE_NTOHL (0x0),  // name = Bytes128
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313238), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128Sequence:1.0
                17,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313238), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Bytes128Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          128U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes128Seq),
    (char *) &_oc_TP_Test_Bytes128Seq,
    0,
    sizeof (TP_Test::Bytes128Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128Seq =
    &_tc_TAO_tc_TP_Test_Bytes128Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes128TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes128TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes128TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes128TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes128TypeSupportInterface>::tao_release (
    TP_Test::Bytes128TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes128TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes128TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes128TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes128TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes128TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes128TypeSupportInterface::Bytes128TypeSupportInterface (void)
{}

TP_Test::Bytes128TypeSupportInterface::~Bytes128TypeSupportInterface (void)
{}

void 
TP_Test::Bytes128TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes128TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes128TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes128TypeSupportInterface_ptr
TP_Test::Bytes128TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128TypeSupportInterface::_nil ();
    }
  
  Bytes128TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes128TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes128TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes128TypeSupportInterface_ptr
TP_Test::Bytes128TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128TypeSupportInterface::_nil ();
    }
  
  Bytes128TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes128TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes128TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes128TypeSupportInterface_ptr
TP_Test::Bytes128TypeSupportInterface::_duplicate (Bytes128TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes128TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes128TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes128TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes128TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes128TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes128TypeSupportInterface:1.0
    29,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Bytes128TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes128TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes128TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes128TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes128TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes128DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes128DataWriter>::tao_duplicate (
    TP_Test::Bytes128DataWriter_ptr p
  )
{
  return TP_Test::Bytes128DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes128DataWriter>::tao_release (
    TP_Test::Bytes128DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes128DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes128DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes128DataWriter>::tao_marshal (
    TP_Test::Bytes128DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes128DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes128DataWriter::Bytes128DataWriter (void)
{}

TP_Test::Bytes128DataWriter::~Bytes128DataWriter (void)
{}

void 
TP_Test::Bytes128DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes128DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes128DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes128DataWriter_ptr
TP_Test::Bytes128DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128DataWriter::_nil ();
    }
  
  Bytes128DataWriter_ptr proxy =
    dynamic_cast<Bytes128DataWriter_ptr> (_tao_objref);
  
  return Bytes128DataWriter::_duplicate (proxy);
}

TP_Test::Bytes128DataWriter_ptr
TP_Test::Bytes128DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128DataWriter::_nil ();
    }
  
  Bytes128DataWriter_ptr proxy =
    dynamic_cast<Bytes128DataWriter_ptr> (_tao_objref);
  
  return Bytes128DataWriter::_duplicate (proxy);
}

TP_Test::Bytes128DataWriter_ptr
TP_Test::Bytes128DataWriter::_duplicate (Bytes128DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes128DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes128DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes128DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes128DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes128DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes128DataWriter:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Bytes128DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes128DataWriter),
    (char *) &_oc_TP_Test_Bytes128DataWriter,
    0,
    sizeof (TP_Test::Bytes128DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes128DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes128DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes128DataReader>::tao_duplicate (
    TP_Test::Bytes128DataReader_ptr p
  )
{
  return TP_Test::Bytes128DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes128DataReader>::tao_release (
    TP_Test::Bytes128DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes128DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes128DataReader>::tao_nil (void)
{
  return TP_Test::Bytes128DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes128DataReader>::tao_marshal (
    TP_Test::Bytes128DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes128DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes128DataReader::Bytes128DataReader (void)
{}

TP_Test::Bytes128DataReader::~Bytes128DataReader (void)
{}

void 
TP_Test::Bytes128DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes128DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes128DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes128DataReader_ptr
TP_Test::Bytes128DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128DataReader::_nil ();
    }
  
  Bytes128DataReader_ptr proxy =
    dynamic_cast<Bytes128DataReader_ptr> (_tao_objref);
  
  return Bytes128DataReader::_duplicate (proxy);
}

TP_Test::Bytes128DataReader_ptr
TP_Test::Bytes128DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes128DataReader::_nil ();
    }
  
  Bytes128DataReader_ptr proxy =
    dynamic_cast<Bytes128DataReader_ptr> (_tao_objref);
  
  return Bytes128DataReader::_duplicate (proxy);
}

TP_Test::Bytes128DataReader_ptr
TP_Test::Bytes128DataReader::_duplicate (Bytes128DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes128DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes128DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes128DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes128DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes128DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes128DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes128DataReader:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313238), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Bytes128DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes128DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes128DataReader),
    (char *) &_oc_TP_Test_Bytes128DataReader,
    0,
    sizeof (TP_Test::Bytes128DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes128DataReader =
    &_tc_TAO_tc_TP_Test_Bytes128DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES256SEQ_CS_)
#define _TP_TEST_BYTES256SEQ_CS_

TP_Test::Bytes256Seq::Bytes256Seq (void)
{}

TP_Test::Bytes256Seq::Bytes256Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes256
      >
    (max)
{}

TP_Test::Bytes256Seq::Bytes256Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes256 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes256
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes256Seq::Bytes256Seq (
    const Bytes256Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes256
      >
    (seq)
{}

TP_Test::Bytes256Seq::~Bytes256Seq (void)
{}

void TP_Test::Bytes256Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes256Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes256Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes256Seq:1.0
    12,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x53657100),  // name = Bytes256Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      25,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73323536), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256:1.0
            9,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73323536), 
      ACE_NTOHL (0x0),  // name = Bytes256
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73323536), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256Sequence:1.0
                17,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73323536), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Bytes256Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          256U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes256Seq),
    (char *) &_oc_TP_Test_Bytes256Seq,
    0,
    sizeof (TP_Test::Bytes256Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256Seq =
    &_tc_TAO_tc_TP_Test_Bytes256Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes256TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes256TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes256TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes256TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes256TypeSupportInterface>::tao_release (
    TP_Test::Bytes256TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes256TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes256TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes256TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes256TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes256TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes256TypeSupportInterface::Bytes256TypeSupportInterface (void)
{}

TP_Test::Bytes256TypeSupportInterface::~Bytes256TypeSupportInterface (void)
{}

void 
TP_Test::Bytes256TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes256TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes256TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes256TypeSupportInterface_ptr
TP_Test::Bytes256TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256TypeSupportInterface::_nil ();
    }
  
  Bytes256TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes256TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes256TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes256TypeSupportInterface_ptr
TP_Test::Bytes256TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256TypeSupportInterface::_nil ();
    }
  
  Bytes256TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes256TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes256TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes256TypeSupportInterface_ptr
TP_Test::Bytes256TypeSupportInterface::_duplicate (Bytes256TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes256TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes256TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes256TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes256TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes256TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes256TypeSupportInterface:1.0
    29,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Bytes256TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes256TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes256TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes256TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes256TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes256DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes256DataWriter>::tao_duplicate (
    TP_Test::Bytes256DataWriter_ptr p
  )
{
  return TP_Test::Bytes256DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes256DataWriter>::tao_release (
    TP_Test::Bytes256DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes256DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes256DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes256DataWriter>::tao_marshal (
    TP_Test::Bytes256DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes256DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes256DataWriter::Bytes256DataWriter (void)
{}

TP_Test::Bytes256DataWriter::~Bytes256DataWriter (void)
{}

void 
TP_Test::Bytes256DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes256DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes256DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes256DataWriter_ptr
TP_Test::Bytes256DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256DataWriter::_nil ();
    }
  
  Bytes256DataWriter_ptr proxy =
    dynamic_cast<Bytes256DataWriter_ptr> (_tao_objref);
  
  return Bytes256DataWriter::_duplicate (proxy);
}

TP_Test::Bytes256DataWriter_ptr
TP_Test::Bytes256DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256DataWriter::_nil ();
    }
  
  Bytes256DataWriter_ptr proxy =
    dynamic_cast<Bytes256DataWriter_ptr> (_tao_objref);
  
  return Bytes256DataWriter::_duplicate (proxy);
}

TP_Test::Bytes256DataWriter_ptr
TP_Test::Bytes256DataWriter::_duplicate (Bytes256DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes256DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes256DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes256DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes256DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes256DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes256DataWriter:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Bytes256DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes256DataWriter),
    (char *) &_oc_TP_Test_Bytes256DataWriter,
    0,
    sizeof (TP_Test::Bytes256DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes256DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes256DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes256DataReader>::tao_duplicate (
    TP_Test::Bytes256DataReader_ptr p
  )
{
  return TP_Test::Bytes256DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes256DataReader>::tao_release (
    TP_Test::Bytes256DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes256DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes256DataReader>::tao_nil (void)
{
  return TP_Test::Bytes256DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes256DataReader>::tao_marshal (
    TP_Test::Bytes256DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes256DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes256DataReader::Bytes256DataReader (void)
{}

TP_Test::Bytes256DataReader::~Bytes256DataReader (void)
{}

void 
TP_Test::Bytes256DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes256DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes256DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes256DataReader_ptr
TP_Test::Bytes256DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256DataReader::_nil ();
    }
  
  Bytes256DataReader_ptr proxy =
    dynamic_cast<Bytes256DataReader_ptr> (_tao_objref);
  
  return Bytes256DataReader::_duplicate (proxy);
}

TP_Test::Bytes256DataReader_ptr
TP_Test::Bytes256DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes256DataReader::_nil ();
    }
  
  Bytes256DataReader_ptr proxy =
    dynamic_cast<Bytes256DataReader_ptr> (_tao_objref);
  
  return Bytes256DataReader::_duplicate (proxy);
}

TP_Test::Bytes256DataReader_ptr
TP_Test::Bytes256DataReader::_duplicate (Bytes256DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes256DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes256DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes256DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes256DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes256DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes256DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes256DataReader:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323536), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Bytes256DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes256DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes256DataReader),
    (char *) &_oc_TP_Test_Bytes256DataReader,
    0,
    sizeof (TP_Test::Bytes256DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes256DataReader =
    &_tc_TAO_tc_TP_Test_Bytes256DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES512SEQ_CS_)
#define _TP_TEST_BYTES512SEQ_CS_

TP_Test::Bytes512Seq::Bytes512Seq (void)
{}

TP_Test::Bytes512Seq::Bytes512Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes512
      >
    (max)
{}

TP_Test::Bytes512Seq::Bytes512Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes512 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes512
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes512Seq::Bytes512Seq (
    const Bytes512Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes512
      >
    (seq)
{}

TP_Test::Bytes512Seq::~Bytes512Seq (void)
{}

void TP_Test::Bytes512Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes512Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes512Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes512Seq:1.0
    12,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x53657100),  // name = Bytes512Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      25,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73353132), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512:1.0
            9,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73353132), 
      ACE_NTOHL (0x0),  // name = Bytes512
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73353132), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512Sequence:1.0
                17,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73353132), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Bytes512Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          512U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes512Seq),
    (char *) &_oc_TP_Test_Bytes512Seq,
    0,
    sizeof (TP_Test::Bytes512Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512Seq =
    &_tc_TAO_tc_TP_Test_Bytes512Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes512TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes512TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes512TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes512TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes512TypeSupportInterface>::tao_release (
    TP_Test::Bytes512TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes512TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes512TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes512TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes512TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes512TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes512TypeSupportInterface::Bytes512TypeSupportInterface (void)
{}

TP_Test::Bytes512TypeSupportInterface::~Bytes512TypeSupportInterface (void)
{}

void 
TP_Test::Bytes512TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes512TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes512TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes512TypeSupportInterface_ptr
TP_Test::Bytes512TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512TypeSupportInterface::_nil ();
    }
  
  Bytes512TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes512TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes512TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes512TypeSupportInterface_ptr
TP_Test::Bytes512TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512TypeSupportInterface::_nil ();
    }
  
  Bytes512TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes512TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes512TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes512TypeSupportInterface_ptr
TP_Test::Bytes512TypeSupportInterface::_duplicate (Bytes512TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes512TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes512TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes512TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes512TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes512TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes512TypeSupportInterface:1.0
    29,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Bytes512TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes512TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes512TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes512TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes512TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes512DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes512DataWriter>::tao_duplicate (
    TP_Test::Bytes512DataWriter_ptr p
  )
{
  return TP_Test::Bytes512DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes512DataWriter>::tao_release (
    TP_Test::Bytes512DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes512DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes512DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes512DataWriter>::tao_marshal (
    TP_Test::Bytes512DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes512DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes512DataWriter::Bytes512DataWriter (void)
{}

TP_Test::Bytes512DataWriter::~Bytes512DataWriter (void)
{}

void 
TP_Test::Bytes512DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes512DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes512DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes512DataWriter_ptr
TP_Test::Bytes512DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512DataWriter::_nil ();
    }
  
  Bytes512DataWriter_ptr proxy =
    dynamic_cast<Bytes512DataWriter_ptr> (_tao_objref);
  
  return Bytes512DataWriter::_duplicate (proxy);
}

TP_Test::Bytes512DataWriter_ptr
TP_Test::Bytes512DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512DataWriter::_nil ();
    }
  
  Bytes512DataWriter_ptr proxy =
    dynamic_cast<Bytes512DataWriter_ptr> (_tao_objref);
  
  return Bytes512DataWriter::_duplicate (proxy);
}

TP_Test::Bytes512DataWriter_ptr
TP_Test::Bytes512DataWriter::_duplicate (Bytes512DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes512DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes512DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes512DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes512DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes512DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes512DataWriter:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Bytes512DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes512DataWriter),
    (char *) &_oc_TP_Test_Bytes512DataWriter,
    0,
    sizeof (TP_Test::Bytes512DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes512DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes512DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes512DataReader>::tao_duplicate (
    TP_Test::Bytes512DataReader_ptr p
  )
{
  return TP_Test::Bytes512DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes512DataReader>::tao_release (
    TP_Test::Bytes512DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes512DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes512DataReader>::tao_nil (void)
{
  return TP_Test::Bytes512DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes512DataReader>::tao_marshal (
    TP_Test::Bytes512DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes512DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes512DataReader::Bytes512DataReader (void)
{}

TP_Test::Bytes512DataReader::~Bytes512DataReader (void)
{}

void 
TP_Test::Bytes512DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes512DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes512DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes512DataReader_ptr
TP_Test::Bytes512DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512DataReader::_nil ();
    }
  
  Bytes512DataReader_ptr proxy =
    dynamic_cast<Bytes512DataReader_ptr> (_tao_objref);
  
  return Bytes512DataReader::_duplicate (proxy);
}

TP_Test::Bytes512DataReader_ptr
TP_Test::Bytes512DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes512DataReader::_nil ();
    }
  
  Bytes512DataReader_ptr proxy =
    dynamic_cast<Bytes512DataReader_ptr> (_tao_objref);
  
  return Bytes512DataReader::_duplicate (proxy);
}

TP_Test::Bytes512DataReader_ptr
TP_Test::Bytes512DataReader::_duplicate (Bytes512DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes512DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes512DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes512DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes512DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes512DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes512DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes512DataReader:1.0
    19,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73353132), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Bytes512DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes512DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes512DataReader),
    (char *) &_oc_TP_Test_Bytes512DataReader,
    0,
    sizeof (TP_Test::Bytes512DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes512DataReader =
    &_tc_TAO_tc_TP_Test_Bytes512DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES1024SEQ_CS_)
#define _TP_TEST_BYTES1024SEQ_CS_

TP_Test::Bytes1024Seq::Bytes1024Seq (void)
{}

TP_Test::Bytes1024Seq::Bytes1024Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes1024
      >
    (max)
{}

TP_Test::Bytes1024Seq::Bytes1024Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes1024 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes1024
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes1024Seq::Bytes1024Seq (
    const Bytes1024Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes1024
      >
    (seq)
{}

TP_Test::Bytes1024Seq::~Bytes1024Seq (void)
{}

void TP_Test::Bytes1024Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes1024Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes1024Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes1024Seq:1.0
    13,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x0),  // name = Bytes1024Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313032), 
      ACE_NTOHL (0x343a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024:1.0
            10,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313032), 
      ACE_NTOHL (0x34000000),  // name = Bytes1024
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313032), 
        ACE_NTOHL (0x34536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024Sequence:1.0
                18,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313032), 
        ACE_NTOHL (0x34536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Bytes1024Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          1024U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes1024Seq),
    (char *) &_oc_TP_Test_Bytes1024Seq,
    0,
    sizeof (TP_Test::Bytes1024Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024Seq =
    &_tc_TAO_tc_TP_Test_Bytes1024Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes1024TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes1024TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes1024TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes1024TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes1024TypeSupportInterface>::tao_release (
    TP_Test::Bytes1024TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes1024TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes1024TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes1024TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes1024TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes1024TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes1024TypeSupportInterface::Bytes1024TypeSupportInterface (void)
{}

TP_Test::Bytes1024TypeSupportInterface::~Bytes1024TypeSupportInterface (void)
{}

void 
TP_Test::Bytes1024TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes1024TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes1024TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes1024TypeSupportInterface_ptr
TP_Test::Bytes1024TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024TypeSupportInterface::_nil ();
    }
  
  Bytes1024TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes1024TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes1024TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes1024TypeSupportInterface_ptr
TP_Test::Bytes1024TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024TypeSupportInterface::_nil ();
    }
  
  Bytes1024TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes1024TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes1024TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes1024TypeSupportInterface_ptr
TP_Test::Bytes1024TypeSupportInterface::_duplicate (Bytes1024TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes1024TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes1024TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes1024TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes1024TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes1024TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes1024TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Bytes1024TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes1024TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes1024TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes1024TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes1024TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes1024DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes1024DataWriter>::tao_duplicate (
    TP_Test::Bytes1024DataWriter_ptr p
  )
{
  return TP_Test::Bytes1024DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes1024DataWriter>::tao_release (
    TP_Test::Bytes1024DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes1024DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes1024DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes1024DataWriter>::tao_marshal (
    TP_Test::Bytes1024DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes1024DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes1024DataWriter::Bytes1024DataWriter (void)
{}

TP_Test::Bytes1024DataWriter::~Bytes1024DataWriter (void)
{}

void 
TP_Test::Bytes1024DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes1024DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes1024DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes1024DataWriter_ptr
TP_Test::Bytes1024DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024DataWriter::_nil ();
    }
  
  Bytes1024DataWriter_ptr proxy =
    dynamic_cast<Bytes1024DataWriter_ptr> (_tao_objref);
  
  return Bytes1024DataWriter::_duplicate (proxy);
}

TP_Test::Bytes1024DataWriter_ptr
TP_Test::Bytes1024DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024DataWriter::_nil ();
    }
  
  Bytes1024DataWriter_ptr proxy =
    dynamic_cast<Bytes1024DataWriter_ptr> (_tao_objref);
  
  return Bytes1024DataWriter::_duplicate (proxy);
}

TP_Test::Bytes1024DataWriter_ptr
TP_Test::Bytes1024DataWriter::_duplicate (Bytes1024DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes1024DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes1024DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes1024DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes1024DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes1024DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes1024DataWriter:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Bytes1024DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes1024DataWriter),
    (char *) &_oc_TP_Test_Bytes1024DataWriter,
    0,
    sizeof (TP_Test::Bytes1024DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes1024DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes1024DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes1024DataReader>::tao_duplicate (
    TP_Test::Bytes1024DataReader_ptr p
  )
{
  return TP_Test::Bytes1024DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes1024DataReader>::tao_release (
    TP_Test::Bytes1024DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes1024DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes1024DataReader>::tao_nil (void)
{
  return TP_Test::Bytes1024DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes1024DataReader>::tao_marshal (
    TP_Test::Bytes1024DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes1024DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes1024DataReader::Bytes1024DataReader (void)
{}

TP_Test::Bytes1024DataReader::~Bytes1024DataReader (void)
{}

void 
TP_Test::Bytes1024DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes1024DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes1024DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes1024DataReader_ptr
TP_Test::Bytes1024DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024DataReader::_nil ();
    }
  
  Bytes1024DataReader_ptr proxy =
    dynamic_cast<Bytes1024DataReader_ptr> (_tao_objref);
  
  return Bytes1024DataReader::_duplicate (proxy);
}

TP_Test::Bytes1024DataReader_ptr
TP_Test::Bytes1024DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes1024DataReader::_nil ();
    }
  
  Bytes1024DataReader_ptr proxy =
    dynamic_cast<Bytes1024DataReader_ptr> (_tao_objref);
  
  return Bytes1024DataReader::_duplicate (proxy);
}

TP_Test::Bytes1024DataReader_ptr
TP_Test::Bytes1024DataReader::_duplicate (Bytes1024DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes1024DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes1024DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes1024DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes1024DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes1024DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes1024DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes1024DataReader:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313032), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Bytes1024DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes1024DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes1024DataReader),
    (char *) &_oc_TP_Test_Bytes1024DataReader,
    0,
    sizeof (TP_Test::Bytes1024DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes1024DataReader =
    &_tc_TAO_tc_TP_Test_Bytes1024DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES2048SEQ_CS_)
#define _TP_TEST_BYTES2048SEQ_CS_

TP_Test::Bytes2048Seq::Bytes2048Seq (void)
{}

TP_Test::Bytes2048Seq::Bytes2048Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes2048
      >
    (max)
{}

TP_Test::Bytes2048Seq::Bytes2048Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes2048 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes2048
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes2048Seq::Bytes2048Seq (
    const Bytes2048Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes2048
      >
    (seq)
{}

TP_Test::Bytes2048Seq::~Bytes2048Seq (void)
{}

void TP_Test::Bytes2048Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes2048Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes2048Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes2048Seq:1.0
    13,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38536571), 
  ACE_NTOHL (0x0),  // name = Bytes2048Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73323034), 
      ACE_NTOHL (0x383a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048:1.0
            10,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73323034), 
      ACE_NTOHL (0x38000000),  // name = Bytes2048
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73323034), 
        ACE_NTOHL (0x38536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048Sequence:1.0
                18,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73323034), 
        ACE_NTOHL (0x38536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Bytes2048Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          2048U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes2048Seq),
    (char *) &_oc_TP_Test_Bytes2048Seq,
    0,
    sizeof (TP_Test::Bytes2048Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048Seq =
    &_tc_TAO_tc_TP_Test_Bytes2048Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes2048TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes2048TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes2048TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes2048TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes2048TypeSupportInterface>::tao_release (
    TP_Test::Bytes2048TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes2048TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes2048TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes2048TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes2048TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes2048TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes2048TypeSupportInterface::Bytes2048TypeSupportInterface (void)
{}

TP_Test::Bytes2048TypeSupportInterface::~Bytes2048TypeSupportInterface (void)
{}

void 
TP_Test::Bytes2048TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes2048TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes2048TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes2048TypeSupportInterface_ptr
TP_Test::Bytes2048TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048TypeSupportInterface::_nil ();
    }
  
  Bytes2048TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes2048TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes2048TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes2048TypeSupportInterface_ptr
TP_Test::Bytes2048TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048TypeSupportInterface::_nil ();
    }
  
  Bytes2048TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes2048TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes2048TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes2048TypeSupportInterface_ptr
TP_Test::Bytes2048TypeSupportInterface::_duplicate (Bytes2048TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes2048TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes2048TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes2048TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes2048TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes2048TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes2048TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Bytes2048TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes2048TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes2048TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes2048TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes2048TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes2048DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes2048DataWriter>::tao_duplicate (
    TP_Test::Bytes2048DataWriter_ptr p
  )
{
  return TP_Test::Bytes2048DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes2048DataWriter>::tao_release (
    TP_Test::Bytes2048DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes2048DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes2048DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes2048DataWriter>::tao_marshal (
    TP_Test::Bytes2048DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes2048DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes2048DataWriter::Bytes2048DataWriter (void)
{}

TP_Test::Bytes2048DataWriter::~Bytes2048DataWriter (void)
{}

void 
TP_Test::Bytes2048DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes2048DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes2048DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes2048DataWriter_ptr
TP_Test::Bytes2048DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048DataWriter::_nil ();
    }
  
  Bytes2048DataWriter_ptr proxy =
    dynamic_cast<Bytes2048DataWriter_ptr> (_tao_objref);
  
  return Bytes2048DataWriter::_duplicate (proxy);
}

TP_Test::Bytes2048DataWriter_ptr
TP_Test::Bytes2048DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048DataWriter::_nil ();
    }
  
  Bytes2048DataWriter_ptr proxy =
    dynamic_cast<Bytes2048DataWriter_ptr> (_tao_objref);
  
  return Bytes2048DataWriter::_duplicate (proxy);
}

TP_Test::Bytes2048DataWriter_ptr
TP_Test::Bytes2048DataWriter::_duplicate (Bytes2048DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes2048DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes2048DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes2048DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes2048DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes2048DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes2048DataWriter:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Bytes2048DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes2048DataWriter),
    (char *) &_oc_TP_Test_Bytes2048DataWriter,
    0,
    sizeof (TP_Test::Bytes2048DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes2048DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes2048DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes2048DataReader>::tao_duplicate (
    TP_Test::Bytes2048DataReader_ptr p
  )
{
  return TP_Test::Bytes2048DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes2048DataReader>::tao_release (
    TP_Test::Bytes2048DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes2048DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes2048DataReader>::tao_nil (void)
{
  return TP_Test::Bytes2048DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes2048DataReader>::tao_marshal (
    TP_Test::Bytes2048DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes2048DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes2048DataReader::Bytes2048DataReader (void)
{}

TP_Test::Bytes2048DataReader::~Bytes2048DataReader (void)
{}

void 
TP_Test::Bytes2048DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes2048DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes2048DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes2048DataReader_ptr
TP_Test::Bytes2048DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048DataReader::_nil ();
    }
  
  Bytes2048DataReader_ptr proxy =
    dynamic_cast<Bytes2048DataReader_ptr> (_tao_objref);
  
  return Bytes2048DataReader::_duplicate (proxy);
}

TP_Test::Bytes2048DataReader_ptr
TP_Test::Bytes2048DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes2048DataReader::_nil ();
    }
  
  Bytes2048DataReader_ptr proxy =
    dynamic_cast<Bytes2048DataReader_ptr> (_tao_objref);
  
  return Bytes2048DataReader::_duplicate (proxy);
}

TP_Test::Bytes2048DataReader_ptr
TP_Test::Bytes2048DataReader::_duplicate (Bytes2048DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes2048DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes2048DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes2048DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes2048DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes2048DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes2048DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes2048DataReader:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73323034), 
  ACE_NTOHL (0x38446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Bytes2048DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes2048DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes2048DataReader),
    (char *) &_oc_TP_Test_Bytes2048DataReader,
    0,
    sizeof (TP_Test::Bytes2048DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes2048DataReader =
    &_tc_TAO_tc_TP_Test_Bytes2048DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES4096SEQ_CS_)
#define _TP_TEST_BYTES4096SEQ_CS_

TP_Test::Bytes4096Seq::Bytes4096Seq (void)
{}

TP_Test::Bytes4096Seq::Bytes4096Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4096
      >
    (max)
{}

TP_Test::Bytes4096Seq::Bytes4096Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes4096 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4096
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes4096Seq::Bytes4096Seq (
    const Bytes4096Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes4096
      >
    (seq)
{}

TP_Test::Bytes4096Seq::~Bytes4096Seq (void)
{}

void TP_Test::Bytes4096Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes4096Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes4096Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes4096Seq:1.0
    13,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x0),  // name = Bytes4096Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73343039), 
      ACE_NTOHL (0x363a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096:1.0
            10,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73343039), 
      ACE_NTOHL (0x36000000),  // name = Bytes4096
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73343039), 
        ACE_NTOHL (0x36536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096Sequence:1.0
                18,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73343039), 
        ACE_NTOHL (0x36536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Bytes4096Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          4096U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes4096Seq),
    (char *) &_oc_TP_Test_Bytes4096Seq,
    0,
    sizeof (TP_Test::Bytes4096Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096Seq =
    &_tc_TAO_tc_TP_Test_Bytes4096Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4096TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes4096TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes4096TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes4096TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4096TypeSupportInterface>::tao_release (
    TP_Test::Bytes4096TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes4096TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes4096TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4096TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes4096TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4096TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4096TypeSupportInterface::Bytes4096TypeSupportInterface (void)
{}

TP_Test::Bytes4096TypeSupportInterface::~Bytes4096TypeSupportInterface (void)
{}

void 
TP_Test::Bytes4096TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4096TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes4096TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4096TypeSupportInterface_ptr
TP_Test::Bytes4096TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096TypeSupportInterface::_nil ();
    }
  
  Bytes4096TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes4096TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes4096TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes4096TypeSupportInterface_ptr
TP_Test::Bytes4096TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096TypeSupportInterface::_nil ();
    }
  
  Bytes4096TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes4096TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes4096TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes4096TypeSupportInterface_ptr
TP_Test::Bytes4096TypeSupportInterface::_duplicate (Bytes4096TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4096TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4096TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4096TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4096TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes4096TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes4096TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Bytes4096TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4096TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes4096TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes4096TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes4096TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4096DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes4096DataWriter>::tao_duplicate (
    TP_Test::Bytes4096DataWriter_ptr p
  )
{
  return TP_Test::Bytes4096DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4096DataWriter>::tao_release (
    TP_Test::Bytes4096DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes4096DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes4096DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4096DataWriter>::tao_marshal (
    TP_Test::Bytes4096DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4096DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4096DataWriter::Bytes4096DataWriter (void)
{}

TP_Test::Bytes4096DataWriter::~Bytes4096DataWriter (void)
{}

void 
TP_Test::Bytes4096DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4096DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes4096DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4096DataWriter_ptr
TP_Test::Bytes4096DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096DataWriter::_nil ();
    }
  
  Bytes4096DataWriter_ptr proxy =
    dynamic_cast<Bytes4096DataWriter_ptr> (_tao_objref);
  
  return Bytes4096DataWriter::_duplicate (proxy);
}

TP_Test::Bytes4096DataWriter_ptr
TP_Test::Bytes4096DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096DataWriter::_nil ();
    }
  
  Bytes4096DataWriter_ptr proxy =
    dynamic_cast<Bytes4096DataWriter_ptr> (_tao_objref);
  
  return Bytes4096DataWriter::_duplicate (proxy);
}

TP_Test::Bytes4096DataWriter_ptr
TP_Test::Bytes4096DataWriter::_duplicate (Bytes4096DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4096DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4096DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4096DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4096DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes4096DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes4096DataWriter:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Bytes4096DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4096DataWriter),
    (char *) &_oc_TP_Test_Bytes4096DataWriter,
    0,
    sizeof (TP_Test::Bytes4096DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes4096DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes4096DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes4096DataReader>::tao_duplicate (
    TP_Test::Bytes4096DataReader_ptr p
  )
{
  return TP_Test::Bytes4096DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes4096DataReader>::tao_release (
    TP_Test::Bytes4096DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes4096DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes4096DataReader>::tao_nil (void)
{
  return TP_Test::Bytes4096DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes4096DataReader>::tao_marshal (
    TP_Test::Bytes4096DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes4096DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes4096DataReader::Bytes4096DataReader (void)
{}

TP_Test::Bytes4096DataReader::~Bytes4096DataReader (void)
{}

void 
TP_Test::Bytes4096DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes4096DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes4096DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes4096DataReader_ptr
TP_Test::Bytes4096DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096DataReader::_nil ();
    }
  
  Bytes4096DataReader_ptr proxy =
    dynamic_cast<Bytes4096DataReader_ptr> (_tao_objref);
  
  return Bytes4096DataReader::_duplicate (proxy);
}

TP_Test::Bytes4096DataReader_ptr
TP_Test::Bytes4096DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes4096DataReader::_nil ();
    }
  
  Bytes4096DataReader_ptr proxy =
    dynamic_cast<Bytes4096DataReader_ptr> (_tao_objref);
  
  return Bytes4096DataReader::_duplicate (proxy);
}

TP_Test::Bytes4096DataReader_ptr
TP_Test::Bytes4096DataReader::_duplicate (Bytes4096DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes4096DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes4096DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes4096DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes4096DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes4096DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes4096DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes4096DataReader:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73343039), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Bytes4096DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes4096DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes4096DataReader),
    (char *) &_oc_TP_Test_Bytes4096DataReader,
    0,
    sizeof (TP_Test::Bytes4096DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes4096DataReader =
    &_tc_TAO_tc_TP_Test_Bytes4096DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES8192SEQ_CS_)
#define _TP_TEST_BYTES8192SEQ_CS_

TP_Test::Bytes8192Seq::Bytes8192Seq (void)
{}

TP_Test::Bytes8192Seq::Bytes8192Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8192
      >
    (max)
{}

TP_Test::Bytes8192Seq::Bytes8192Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes8192 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8192
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes8192Seq::Bytes8192Seq (
    const Bytes8192Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes8192
      >
    (seq)
{}

TP_Test::Bytes8192Seq::~Bytes8192Seq (void)
{}

void TP_Test::Bytes8192Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes8192Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes8192Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes8192Seq:1.0
    13,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x0),  // name = Bytes8192Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73383139), 
      ACE_NTOHL (0x323a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192:1.0
            10,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73383139), 
      ACE_NTOHL (0x32000000),  // name = Bytes8192
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73383139), 
        ACE_NTOHL (0x32536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192Sequence:1.0
                18,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73383139), 
        ACE_NTOHL (0x32536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Bytes8192Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          8192U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes8192Seq),
    (char *) &_oc_TP_Test_Bytes8192Seq,
    0,
    sizeof (TP_Test::Bytes8192Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192Seq =
    &_tc_TAO_tc_TP_Test_Bytes8192Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8192TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes8192TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes8192TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes8192TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8192TypeSupportInterface>::tao_release (
    TP_Test::Bytes8192TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes8192TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes8192TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8192TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes8192TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8192TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8192TypeSupportInterface::Bytes8192TypeSupportInterface (void)
{}

TP_Test::Bytes8192TypeSupportInterface::~Bytes8192TypeSupportInterface (void)
{}

void 
TP_Test::Bytes8192TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8192TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes8192TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8192TypeSupportInterface_ptr
TP_Test::Bytes8192TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192TypeSupportInterface::_nil ();
    }
  
  Bytes8192TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes8192TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes8192TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes8192TypeSupportInterface_ptr
TP_Test::Bytes8192TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192TypeSupportInterface::_nil ();
    }
  
  Bytes8192TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes8192TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes8192TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes8192TypeSupportInterface_ptr
TP_Test::Bytes8192TypeSupportInterface::_duplicate (Bytes8192TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8192TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8192TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8192TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8192TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes8192TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes8192TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Bytes8192TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8192TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes8192TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes8192TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes8192TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8192DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes8192DataWriter>::tao_duplicate (
    TP_Test::Bytes8192DataWriter_ptr p
  )
{
  return TP_Test::Bytes8192DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8192DataWriter>::tao_release (
    TP_Test::Bytes8192DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes8192DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes8192DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8192DataWriter>::tao_marshal (
    TP_Test::Bytes8192DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8192DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8192DataWriter::Bytes8192DataWriter (void)
{}

TP_Test::Bytes8192DataWriter::~Bytes8192DataWriter (void)
{}

void 
TP_Test::Bytes8192DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8192DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes8192DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8192DataWriter_ptr
TP_Test::Bytes8192DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192DataWriter::_nil ();
    }
  
  Bytes8192DataWriter_ptr proxy =
    dynamic_cast<Bytes8192DataWriter_ptr> (_tao_objref);
  
  return Bytes8192DataWriter::_duplicate (proxy);
}

TP_Test::Bytes8192DataWriter_ptr
TP_Test::Bytes8192DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192DataWriter::_nil ();
    }
  
  Bytes8192DataWriter_ptr proxy =
    dynamic_cast<Bytes8192DataWriter_ptr> (_tao_objref);
  
  return Bytes8192DataWriter::_duplicate (proxy);
}

TP_Test::Bytes8192DataWriter_ptr
TP_Test::Bytes8192DataWriter::_duplicate (Bytes8192DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8192DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8192DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8192DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8192DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes8192DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes8192DataWriter:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Bytes8192DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8192DataWriter),
    (char *) &_oc_TP_Test_Bytes8192DataWriter,
    0,
    sizeof (TP_Test::Bytes8192DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes8192DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes8192DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes8192DataReader>::tao_duplicate (
    TP_Test::Bytes8192DataReader_ptr p
  )
{
  return TP_Test::Bytes8192DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes8192DataReader>::tao_release (
    TP_Test::Bytes8192DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes8192DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes8192DataReader>::tao_nil (void)
{
  return TP_Test::Bytes8192DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes8192DataReader>::tao_marshal (
    TP_Test::Bytes8192DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes8192DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes8192DataReader::Bytes8192DataReader (void)
{}

TP_Test::Bytes8192DataReader::~Bytes8192DataReader (void)
{}

void 
TP_Test::Bytes8192DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes8192DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes8192DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes8192DataReader_ptr
TP_Test::Bytes8192DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192DataReader::_nil ();
    }
  
  Bytes8192DataReader_ptr proxy =
    dynamic_cast<Bytes8192DataReader_ptr> (_tao_objref);
  
  return Bytes8192DataReader::_duplicate (proxy);
}

TP_Test::Bytes8192DataReader_ptr
TP_Test::Bytes8192DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes8192DataReader::_nil ();
    }
  
  Bytes8192DataReader_ptr proxy =
    dynamic_cast<Bytes8192DataReader_ptr> (_tao_objref);
  
  return Bytes8192DataReader::_duplicate (proxy);
}

TP_Test::Bytes8192DataReader_ptr
TP_Test::Bytes8192DataReader::_duplicate (Bytes8192DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes8192DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes8192DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes8192DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes8192DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes8192DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes8192DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Bytes8192DataReader:1.0
    20,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73383139), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Bytes8192DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes8192DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes8192DataReader),
    (char *) &_oc_TP_Test_Bytes8192DataReader,
    0,
    sizeof (TP_Test::Bytes8192DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes8192DataReader =
    &_tc_TAO_tc_TP_Test_Bytes8192DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_BYTES16384SEQ_CS_)
#define _TP_TEST_BYTES16384SEQ_CS_

TP_Test::Bytes16384Seq::Bytes16384Seq (void)
{}

TP_Test::Bytes16384Seq::Bytes16384Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16384
      >
    (max)
{}

TP_Test::Bytes16384Seq::Bytes16384Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Bytes16384 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16384
      >
    (max, length, buffer, release)
{}

TP_Test::Bytes16384Seq::Bytes16384Seq (
    const Bytes16384Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Bytes16384
      >
    (seq)
{}

TP_Test::Bytes16384Seq::~Bytes16384Seq (void)
{}

void TP_Test::Bytes16384Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Bytes16384Seq * _tao_tmp_pointer =
    ACE_static_cast (Bytes16384Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Bytes16384Seq:1.0
    14,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345365), 
  ACE_NTOHL (0x71000000),  // name = Bytes16384Seq
    CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313633), 
      ACE_NTOHL (0x38343a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384:1.0
            11,
      ACE_NTOHL (0x42797465), 
      ACE_NTOHL (0x73313633), 
      ACE_NTOHL (0x38340000),  // name = Bytes16384
      2, // member count
            10,
      ACE_NTOHL (0x74696d65), 
      ACE_NTOHL (0x7374616d), 
      ACE_NTOHL (0x70000000),  // name = timestamp
            CORBA::tk_ulong,

      5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      88, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313633), 
        ACE_NTOHL (0x38345365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384Sequence:1.0
                19,
        ACE_NTOHL (0x42797465), 
        ACE_NTOHL (0x73313633), 
        ACE_NTOHL (0x38345365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Bytes16384Sequence
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          16384U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Bytes16384Seq),
    (char *) &_oc_TP_Test_Bytes16384Seq,
    0,
    sizeof (TP_Test::Bytes16384Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384Seq =
    &_tc_TAO_tc_TP_Test_Bytes16384Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16384TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes16384TypeSupportInterface>::tao_duplicate (
    TP_Test::Bytes16384TypeSupportInterface_ptr p
  )
{
  return TP_Test::Bytes16384TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16384TypeSupportInterface>::tao_release (
    TP_Test::Bytes16384TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Bytes16384TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Bytes16384TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16384TypeSupportInterface>::tao_marshal (
    TP_Test::Bytes16384TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16384TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16384TypeSupportInterface::Bytes16384TypeSupportInterface (void)
{}

TP_Test::Bytes16384TypeSupportInterface::~Bytes16384TypeSupportInterface (void)
{}

void 
TP_Test::Bytes16384TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16384TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Bytes16384TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16384TypeSupportInterface_ptr
TP_Test::Bytes16384TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384TypeSupportInterface::_nil ();
    }
  
  Bytes16384TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes16384TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes16384TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes16384TypeSupportInterface_ptr
TP_Test::Bytes16384TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384TypeSupportInterface::_nil ();
    }
  
  Bytes16384TypeSupportInterface_ptr proxy =
    dynamic_cast<Bytes16384TypeSupportInterface_ptr> (_tao_objref);
  
  return Bytes16384TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Bytes16384TypeSupportInterface_ptr
TP_Test::Bytes16384TypeSupportInterface::_duplicate (Bytes16384TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16384TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16384TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16384TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16384TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Bytes16384TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Bytes16384TypeSupportInterface:1.0
    31,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38345479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Bytes16384TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16384TypeSupportInterface),
    (char *) &_oc_TP_Test_Bytes16384TypeSupportInterface,
    0,
    sizeof (TP_Test::Bytes16384TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Bytes16384TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16384DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes16384DataWriter>::tao_duplicate (
    TP_Test::Bytes16384DataWriter_ptr p
  )
{
  return TP_Test::Bytes16384DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16384DataWriter>::tao_release (
    TP_Test::Bytes16384DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384DataWriter_ptr
TAO::Objref_Traits<TP_Test::Bytes16384DataWriter>::tao_nil (void)
{
  return TP_Test::Bytes16384DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16384DataWriter>::tao_marshal (
    TP_Test::Bytes16384DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16384DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16384DataWriter::Bytes16384DataWriter (void)
{}

TP_Test::Bytes16384DataWriter::~Bytes16384DataWriter (void)
{}

void 
TP_Test::Bytes16384DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16384DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Bytes16384DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16384DataWriter_ptr
TP_Test::Bytes16384DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384DataWriter::_nil ();
    }
  
  Bytes16384DataWriter_ptr proxy =
    dynamic_cast<Bytes16384DataWriter_ptr> (_tao_objref);
  
  return Bytes16384DataWriter::_duplicate (proxy);
}

TP_Test::Bytes16384DataWriter_ptr
TP_Test::Bytes16384DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384DataWriter::_nil ();
    }
  
  Bytes16384DataWriter_ptr proxy =
    dynamic_cast<Bytes16384DataWriter_ptr> (_tao_objref);
  
  return Bytes16384DataWriter::_duplicate (proxy);
}

TP_Test::Bytes16384DataWriter_ptr
TP_Test::Bytes16384DataWriter::_duplicate (Bytes16384DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16384DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16384DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16384DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16384DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Bytes16384DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38344461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes16384DataWriter:1.0
    21,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38344461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Bytes16384DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16384DataWriter),
    (char *) &_oc_TP_Test_Bytes16384DataWriter,
    0,
    sizeof (TP_Test::Bytes16384DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384DataWriter =
    &_tc_TAO_tc_TP_Test_Bytes16384DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Bytes16384DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes16384DataReader>::tao_duplicate (
    TP_Test::Bytes16384DataReader_ptr p
  )
{
  return TP_Test::Bytes16384DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Bytes16384DataReader>::tao_release (
    TP_Test::Bytes16384DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Bytes16384DataReader_ptr
TAO::Objref_Traits<TP_Test::Bytes16384DataReader>::tao_nil (void)
{
  return TP_Test::Bytes16384DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Bytes16384DataReader>::tao_marshal (
    TP_Test::Bytes16384DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Bytes16384DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Bytes16384DataReader::Bytes16384DataReader (void)
{}

TP_Test::Bytes16384DataReader::~Bytes16384DataReader (void)
{}

void 
TP_Test::Bytes16384DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Bytes16384DataReader *_tao_tmp_pointer =
    ACE_static_cast (Bytes16384DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Bytes16384DataReader_ptr
TP_Test::Bytes16384DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384DataReader::_nil ();
    }
  
  Bytes16384DataReader_ptr proxy =
    dynamic_cast<Bytes16384DataReader_ptr> (_tao_objref);
  
  return Bytes16384DataReader::_duplicate (proxy);
}

TP_Test::Bytes16384DataReader_ptr
TP_Test::Bytes16384DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Bytes16384DataReader::_nil ();
    }
  
  Bytes16384DataReader_ptr proxy =
    dynamic_cast<Bytes16384DataReader_ptr> (_tao_objref);
  
  return Bytes16384DataReader::_duplicate (proxy);
}

TP_Test::Bytes16384DataReader_ptr
TP_Test::Bytes16384DataReader::_duplicate (Bytes16384DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Bytes16384DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Bytes16384DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Bytes16384DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Bytes16384DataReader:1.0";
}

CORBA::Boolean
TP_Test::Bytes16384DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Bytes16384DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38344461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Bytes16384DataReader:1.0
    21,
  ACE_NTOHL (0x42797465), 
  ACE_NTOHL (0x73313633), 
  ACE_NTOHL (0x38344461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Bytes16384DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Bytes16384DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Bytes16384DataReader),
    (char *) &_oc_TP_Test_Bytes16384DataReader,
    0,
    sizeof (TP_Test::Bytes16384DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Bytes16384DataReader =
    &_tc_TAO_tc_TP_Test_Bytes16384DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX4SEQ_CS_)
#define _TP_TEST_COMPLEX4SEQ_CS_

TP_Test::Complex4Seq::Complex4Seq (void)
{}

TP_Test::Complex4Seq::Complex4Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4
      >
    (max)
{}

TP_Test::Complex4Seq::Complex4Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex4 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4
      >
    (max, length, buffer, release)
{}

TP_Test::Complex4Seq::Complex4Seq (
    const Complex4Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4
      >
    (seq)
{}

TP_Test::Complex4Seq::~Complex4Seq (void)
{}

void TP_Test::Complex4Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex4Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex4Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4Seq:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x53657100),  // name = Complex4Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      25,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657834), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4:1.0
            9,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657834), 
      ACE_NTOHL (0x0),  // name = Complex4
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657834), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4Sequence:1.0
                17,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657834), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Complex4Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          4U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex4Seq),
    (char *) &_oc_TP_Test_Complex4Seq,
    0,
    sizeof (TP_Test::Complex4Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4Seq =
    &_tc_TAO_tc_TP_Test_Complex4Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex4TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex4TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex4TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4TypeSupportInterface>::tao_release (
    TP_Test::Complex4TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex4TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex4TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4TypeSupportInterface>::tao_marshal (
    TP_Test::Complex4TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4TypeSupportInterface::Complex4TypeSupportInterface (void)
{}

TP_Test::Complex4TypeSupportInterface::~Complex4TypeSupportInterface (void)
{}

void 
TP_Test::Complex4TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex4TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4TypeSupportInterface_ptr
TP_Test::Complex4TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4TypeSupportInterface::_nil ();
    }
  
  Complex4TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex4TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex4TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex4TypeSupportInterface_ptr
TP_Test::Complex4TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4TypeSupportInterface::_nil ();
    }
  
  Complex4TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex4TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex4TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex4TypeSupportInterface_ptr
TP_Test::Complex4TypeSupportInterface::_duplicate (Complex4TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex4TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex4TypeSupportInterface:1.0
    29,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Complex4TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex4TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex4TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex4TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex4DataWriter>::tao_duplicate (
    TP_Test::Complex4DataWriter_ptr p
  )
{
  return TP_Test::Complex4DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4DataWriter>::tao_release (
    TP_Test::Complex4DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex4DataWriter>::tao_nil (void)
{
  return TP_Test::Complex4DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4DataWriter>::tao_marshal (
    TP_Test::Complex4DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4DataWriter::Complex4DataWriter (void)
{}

TP_Test::Complex4DataWriter::~Complex4DataWriter (void)
{}

void 
TP_Test::Complex4DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex4DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4DataWriter_ptr
TP_Test::Complex4DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4DataWriter::_nil ();
    }
  
  Complex4DataWriter_ptr proxy =
    dynamic_cast<Complex4DataWriter_ptr> (_tao_objref);
  
  return Complex4DataWriter::_duplicate (proxy);
}

TP_Test::Complex4DataWriter_ptr
TP_Test::Complex4DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4DataWriter::_nil ();
    }
  
  Complex4DataWriter_ptr proxy =
    dynamic_cast<Complex4DataWriter_ptr> (_tao_objref);
  
  return Complex4DataWriter::_duplicate (proxy);
}

TP_Test::Complex4DataWriter_ptr
TP_Test::Complex4DataWriter::_duplicate (Complex4DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex4DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex4DataWriter:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Complex4DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4DataWriter),
    (char *) &_oc_TP_Test_Complex4DataWriter,
    0,
    sizeof (TP_Test::Complex4DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4DataWriter =
    &_tc_TAO_tc_TP_Test_Complex4DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex4DataReader>::tao_duplicate (
    TP_Test::Complex4DataReader_ptr p
  )
{
  return TP_Test::Complex4DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4DataReader>::tao_release (
    TP_Test::Complex4DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex4DataReader>::tao_nil (void)
{
  return TP_Test::Complex4DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4DataReader>::tao_marshal (
    TP_Test::Complex4DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4DataReader::Complex4DataReader (void)
{}

TP_Test::Complex4DataReader::~Complex4DataReader (void)
{}

void 
TP_Test::Complex4DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex4DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4DataReader_ptr
TP_Test::Complex4DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4DataReader::_nil ();
    }
  
  Complex4DataReader_ptr proxy =
    dynamic_cast<Complex4DataReader_ptr> (_tao_objref);
  
  return Complex4DataReader::_duplicate (proxy);
}

TP_Test::Complex4DataReader_ptr
TP_Test::Complex4DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4DataReader::_nil ();
    }
  
  Complex4DataReader_ptr proxy =
    dynamic_cast<Complex4DataReader_ptr> (_tao_objref);
  
  return Complex4DataReader::_duplicate (proxy);
}

TP_Test::Complex4DataReader_ptr
TP_Test::Complex4DataReader::_duplicate (Complex4DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex4DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex4DataReader:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Complex4DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4DataReader),
    (char *) &_oc_TP_Test_Complex4DataReader,
    0,
    sizeof (TP_Test::Complex4DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4DataReader =
    &_tc_TAO_tc_TP_Test_Complex4DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX8SEQ_CS_)
#define _TP_TEST_COMPLEX8SEQ_CS_

TP_Test::Complex8Seq::Complex8Seq (void)
{}

TP_Test::Complex8Seq::Complex8Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8
      >
    (max)
{}

TP_Test::Complex8Seq::Complex8Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex8 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8
      >
    (max, length, buffer, release)
{}

TP_Test::Complex8Seq::Complex8Seq (
    const Complex8Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8
      >
    (seq)
{}

TP_Test::Complex8Seq::~Complex8Seq (void)
{}

void TP_Test::Complex8Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex8Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex8Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8Seq:1.0
    12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x53657100),  // name = Complex8Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      25,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657838), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8:1.0
            9,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657838), 
      ACE_NTOHL (0x0),  // name = Complex8
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657838), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8Sequence:1.0
                17,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657838), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Complex8Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          8U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex8Seq),
    (char *) &_oc_TP_Test_Complex8Seq,
    0,
    sizeof (TP_Test::Complex8Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8Seq =
    &_tc_TAO_tc_TP_Test_Complex8Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex8TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex8TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex8TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8TypeSupportInterface>::tao_release (
    TP_Test::Complex8TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex8TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex8TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8TypeSupportInterface>::tao_marshal (
    TP_Test::Complex8TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8TypeSupportInterface::Complex8TypeSupportInterface (void)
{}

TP_Test::Complex8TypeSupportInterface::~Complex8TypeSupportInterface (void)
{}

void 
TP_Test::Complex8TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex8TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8TypeSupportInterface_ptr
TP_Test::Complex8TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8TypeSupportInterface::_nil ();
    }
  
  Complex8TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex8TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex8TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex8TypeSupportInterface_ptr
TP_Test::Complex8TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8TypeSupportInterface::_nil ();
    }
  
  Complex8TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex8TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex8TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex8TypeSupportInterface_ptr
TP_Test::Complex8TypeSupportInterface::_duplicate (Complex8TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex8TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex8TypeSupportInterface:1.0
    29,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Complex8TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex8TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex8TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex8TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex8DataWriter>::tao_duplicate (
    TP_Test::Complex8DataWriter_ptr p
  )
{
  return TP_Test::Complex8DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8DataWriter>::tao_release (
    TP_Test::Complex8DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex8DataWriter>::tao_nil (void)
{
  return TP_Test::Complex8DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8DataWriter>::tao_marshal (
    TP_Test::Complex8DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8DataWriter::Complex8DataWriter (void)
{}

TP_Test::Complex8DataWriter::~Complex8DataWriter (void)
{}

void 
TP_Test::Complex8DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex8DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8DataWriter_ptr
TP_Test::Complex8DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8DataWriter::_nil ();
    }
  
  Complex8DataWriter_ptr proxy =
    dynamic_cast<Complex8DataWriter_ptr> (_tao_objref);
  
  return Complex8DataWriter::_duplicate (proxy);
}

TP_Test::Complex8DataWriter_ptr
TP_Test::Complex8DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8DataWriter::_nil ();
    }
  
  Complex8DataWriter_ptr proxy =
    dynamic_cast<Complex8DataWriter_ptr> (_tao_objref);
  
  return Complex8DataWriter::_duplicate (proxy);
}

TP_Test::Complex8DataWriter_ptr
TP_Test::Complex8DataWriter::_duplicate (Complex8DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex8DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex8DataWriter:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Complex8DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8DataWriter),
    (char *) &_oc_TP_Test_Complex8DataWriter,
    0,
    sizeof (TP_Test::Complex8DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8DataWriter =
    &_tc_TAO_tc_TP_Test_Complex8DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex8DataReader>::tao_duplicate (
    TP_Test::Complex8DataReader_ptr p
  )
{
  return TP_Test::Complex8DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8DataReader>::tao_release (
    TP_Test::Complex8DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex8DataReader>::tao_nil (void)
{
  return TP_Test::Complex8DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8DataReader>::tao_marshal (
    TP_Test::Complex8DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8DataReader::Complex8DataReader (void)
{}

TP_Test::Complex8DataReader::~Complex8DataReader (void)
{}

void 
TP_Test::Complex8DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex8DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8DataReader_ptr
TP_Test::Complex8DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8DataReader::_nil ();
    }
  
  Complex8DataReader_ptr proxy =
    dynamic_cast<Complex8DataReader_ptr> (_tao_objref);
  
  return Complex8DataReader::_duplicate (proxy);
}

TP_Test::Complex8DataReader_ptr
TP_Test::Complex8DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8DataReader::_nil ();
    }
  
  Complex8DataReader_ptr proxy =
    dynamic_cast<Complex8DataReader_ptr> (_tao_objref);
  
  return Complex8DataReader::_duplicate (proxy);
}

TP_Test::Complex8DataReader_ptr
TP_Test::Complex8DataReader::_duplicate (Complex8DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex8DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex8DataReader:1.0
    19,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Complex8DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8DataReader),
    (char *) &_oc_TP_Test_Complex8DataReader,
    0,
    sizeof (TP_Test::Complex8DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8DataReader =
    &_tc_TAO_tc_TP_Test_Complex8DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX16SEQ_CS_)
#define _TP_TEST_COMPLEX16SEQ_CS_

TP_Test::Complex16Seq::Complex16Seq (void)
{}

TP_Test::Complex16Seq::Complex16Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16
      >
    (max)
{}

TP_Test::Complex16Seq::Complex16Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex16 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16
      >
    (max, length, buffer, release)
{}

TP_Test::Complex16Seq::Complex16Seq (
    const Complex16Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16
      >
    (seq)
{}

TP_Test::Complex16Seq::~Complex16Seq (void)
{}

void TP_Test::Complex16Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex16Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex16Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16Seq:1.0
    13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36536571), 
  ACE_NTOHL (0x0),  // name = Complex16Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x363a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16:1.0
            10,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x36000000),  // name = Complex16
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x36536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16Sequence:1.0
                18,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x36536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Complex16Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          16U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex16Seq),
    (char *) &_oc_TP_Test_Complex16Seq,
    0,
    sizeof (TP_Test::Complex16Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16Seq =
    &_tc_TAO_tc_TP_Test_Complex16Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex16TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex16TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex16TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16TypeSupportInterface>::tao_release (
    TP_Test::Complex16TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex16TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex16TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16TypeSupportInterface>::tao_marshal (
    TP_Test::Complex16TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16TypeSupportInterface::Complex16TypeSupportInterface (void)
{}

TP_Test::Complex16TypeSupportInterface::~Complex16TypeSupportInterface (void)
{}

void 
TP_Test::Complex16TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex16TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16TypeSupportInterface_ptr
TP_Test::Complex16TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16TypeSupportInterface::_nil ();
    }
  
  Complex16TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex16TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex16TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex16TypeSupportInterface_ptr
TP_Test::Complex16TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16TypeSupportInterface::_nil ();
    }
  
  Complex16TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex16TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex16TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex16TypeSupportInterface_ptr
TP_Test::Complex16TypeSupportInterface::_duplicate (Complex16TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex16TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex16TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Complex16TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex16TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex16TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex16TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex16DataWriter>::tao_duplicate (
    TP_Test::Complex16DataWriter_ptr p
  )
{
  return TP_Test::Complex16DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16DataWriter>::tao_release (
    TP_Test::Complex16DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex16DataWriter>::tao_nil (void)
{
  return TP_Test::Complex16DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16DataWriter>::tao_marshal (
    TP_Test::Complex16DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16DataWriter::Complex16DataWriter (void)
{}

TP_Test::Complex16DataWriter::~Complex16DataWriter (void)
{}

void 
TP_Test::Complex16DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex16DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16DataWriter_ptr
TP_Test::Complex16DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16DataWriter::_nil ();
    }
  
  Complex16DataWriter_ptr proxy =
    dynamic_cast<Complex16DataWriter_ptr> (_tao_objref);
  
  return Complex16DataWriter::_duplicate (proxy);
}

TP_Test::Complex16DataWriter_ptr
TP_Test::Complex16DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16DataWriter::_nil ();
    }
  
  Complex16DataWriter_ptr proxy =
    dynamic_cast<Complex16DataWriter_ptr> (_tao_objref);
  
  return Complex16DataWriter::_duplicate (proxy);
}

TP_Test::Complex16DataWriter_ptr
TP_Test::Complex16DataWriter::_duplicate (Complex16DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex16DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex16DataWriter:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Complex16DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16DataWriter),
    (char *) &_oc_TP_Test_Complex16DataWriter,
    0,
    sizeof (TP_Test::Complex16DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16DataWriter =
    &_tc_TAO_tc_TP_Test_Complex16DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex16DataReader>::tao_duplicate (
    TP_Test::Complex16DataReader_ptr p
  )
{
  return TP_Test::Complex16DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16DataReader>::tao_release (
    TP_Test::Complex16DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex16DataReader>::tao_nil (void)
{
  return TP_Test::Complex16DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16DataReader>::tao_marshal (
    TP_Test::Complex16DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16DataReader::Complex16DataReader (void)
{}

TP_Test::Complex16DataReader::~Complex16DataReader (void)
{}

void 
TP_Test::Complex16DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex16DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16DataReader_ptr
TP_Test::Complex16DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16DataReader::_nil ();
    }
  
  Complex16DataReader_ptr proxy =
    dynamic_cast<Complex16DataReader_ptr> (_tao_objref);
  
  return Complex16DataReader::_duplicate (proxy);
}

TP_Test::Complex16DataReader_ptr
TP_Test::Complex16DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16DataReader::_nil ();
    }
  
  Complex16DataReader_ptr proxy =
    dynamic_cast<Complex16DataReader_ptr> (_tao_objref);
  
  return Complex16DataReader::_duplicate (proxy);
}

TP_Test::Complex16DataReader_ptr
TP_Test::Complex16DataReader::_duplicate (Complex16DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex16DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex16DataReader:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Complex16DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16DataReader),
    (char *) &_oc_TP_Test_Complex16DataReader,
    0,
    sizeof (TP_Test::Complex16DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16DataReader =
    &_tc_TAO_tc_TP_Test_Complex16DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX32SEQ_CS_)
#define _TP_TEST_COMPLEX32SEQ_CS_

TP_Test::Complex32Seq::Complex32Seq (void)
{}

TP_Test::Complex32Seq::Complex32Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex32
      >
    (max)
{}

TP_Test::Complex32Seq::Complex32Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex32 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex32
      >
    (max, length, buffer, release)
{}

TP_Test::Complex32Seq::Complex32Seq (
    const Complex32Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex32
      >
    (seq)
{}

TP_Test::Complex32Seq::~Complex32Seq (void)
{}

void TP_Test::Complex32Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex32Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex32Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex32Seq:1.0
    13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32536571), 
  ACE_NTOHL (0x0),  // name = Complex32Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657833), 
      ACE_NTOHL (0x323a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32:1.0
            10,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657833), 
      ACE_NTOHL (0x32000000),  // name = Complex32
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657833), 
        ACE_NTOHL (0x32536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32Sequence:1.0
                18,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657833), 
        ACE_NTOHL (0x32536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Complex32Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          32U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex32Seq),
    (char *) &_oc_TP_Test_Complex32Seq,
    0,
    sizeof (TP_Test::Complex32Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32Seq =
    &_tc_TAO_tc_TP_Test_Complex32Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex32TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex32TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex32TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex32TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex32TypeSupportInterface>::tao_release (
    TP_Test::Complex32TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex32TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex32TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex32TypeSupportInterface>::tao_marshal (
    TP_Test::Complex32TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex32TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex32TypeSupportInterface::Complex32TypeSupportInterface (void)
{}

TP_Test::Complex32TypeSupportInterface::~Complex32TypeSupportInterface (void)
{}

void 
TP_Test::Complex32TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex32TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex32TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex32TypeSupportInterface_ptr
TP_Test::Complex32TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32TypeSupportInterface::_nil ();
    }
  
  Complex32TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex32TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex32TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex32TypeSupportInterface_ptr
TP_Test::Complex32TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32TypeSupportInterface::_nil ();
    }
  
  Complex32TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex32TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex32TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex32TypeSupportInterface_ptr
TP_Test::Complex32TypeSupportInterface::_duplicate (Complex32TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex32TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex32TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex32TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex32TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex32TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex32TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Complex32TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex32TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex32TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex32TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex32TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex32DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex32DataWriter>::tao_duplicate (
    TP_Test::Complex32DataWriter_ptr p
  )
{
  return TP_Test::Complex32DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex32DataWriter>::tao_release (
    TP_Test::Complex32DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex32DataWriter>::tao_nil (void)
{
  return TP_Test::Complex32DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex32DataWriter>::tao_marshal (
    TP_Test::Complex32DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex32DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex32DataWriter::Complex32DataWriter (void)
{}

TP_Test::Complex32DataWriter::~Complex32DataWriter (void)
{}

void 
TP_Test::Complex32DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex32DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex32DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex32DataWriter_ptr
TP_Test::Complex32DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32DataWriter::_nil ();
    }
  
  Complex32DataWriter_ptr proxy =
    dynamic_cast<Complex32DataWriter_ptr> (_tao_objref);
  
  return Complex32DataWriter::_duplicate (proxy);
}

TP_Test::Complex32DataWriter_ptr
TP_Test::Complex32DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32DataWriter::_nil ();
    }
  
  Complex32DataWriter_ptr proxy =
    dynamic_cast<Complex32DataWriter_ptr> (_tao_objref);
  
  return Complex32DataWriter::_duplicate (proxy);
}

TP_Test::Complex32DataWriter_ptr
TP_Test::Complex32DataWriter::_duplicate (Complex32DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex32DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex32DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex32DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex32DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex32DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex32DataWriter:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Complex32DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex32DataWriter),
    (char *) &_oc_TP_Test_Complex32DataWriter,
    0,
    sizeof (TP_Test::Complex32DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32DataWriter =
    &_tc_TAO_tc_TP_Test_Complex32DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex32DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex32DataReader>::tao_duplicate (
    TP_Test::Complex32DataReader_ptr p
  )
{
  return TP_Test::Complex32DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex32DataReader>::tao_release (
    TP_Test::Complex32DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex32DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex32DataReader>::tao_nil (void)
{
  return TP_Test::Complex32DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex32DataReader>::tao_marshal (
    TP_Test::Complex32DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex32DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex32DataReader::Complex32DataReader (void)
{}

TP_Test::Complex32DataReader::~Complex32DataReader (void)
{}

void 
TP_Test::Complex32DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex32DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex32DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex32DataReader_ptr
TP_Test::Complex32DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32DataReader::_nil ();
    }
  
  Complex32DataReader_ptr proxy =
    dynamic_cast<Complex32DataReader_ptr> (_tao_objref);
  
  return Complex32DataReader::_duplicate (proxy);
}

TP_Test::Complex32DataReader_ptr
TP_Test::Complex32DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex32DataReader::_nil ();
    }
  
  Complex32DataReader_ptr proxy =
    dynamic_cast<Complex32DataReader_ptr> (_tao_objref);
  
  return Complex32DataReader::_duplicate (proxy);
}

TP_Test::Complex32DataReader_ptr
TP_Test::Complex32DataReader::_duplicate (Complex32DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex32DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex32DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex32DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex32DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex32DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex32DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex32DataReader:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657833), 
  ACE_NTOHL (0x32446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Complex32DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex32DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex32DataReader),
    (char *) &_oc_TP_Test_Complex32DataReader,
    0,
    sizeof (TP_Test::Complex32DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex32DataReader =
    &_tc_TAO_tc_TP_Test_Complex32DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX64SEQ_CS_)
#define _TP_TEST_COMPLEX64SEQ_CS_

TP_Test::Complex64Seq::Complex64Seq (void)
{}

TP_Test::Complex64Seq::Complex64Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex64
      >
    (max)
{}

TP_Test::Complex64Seq::Complex64Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex64 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex64
      >
    (max, length, buffer, release)
{}

TP_Test::Complex64Seq::Complex64Seq (
    const Complex64Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex64
      >
    (seq)
{}

TP_Test::Complex64Seq::~Complex64Seq (void)
{}

void TP_Test::Complex64Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex64Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex64Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex64Seq:1.0
    13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34536571), 
  ACE_NTOHL (0x0),  // name = Complex64Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      26,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657836), 
      ACE_NTOHL (0x343a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64:1.0
            10,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657836), 
      ACE_NTOHL (0x34000000),  // name = Complex64
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657836), 
        ACE_NTOHL (0x34536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64Sequence:1.0
                18,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657836), 
        ACE_NTOHL (0x34536571), 
        ACE_NTOHL (0x75656e63), 
        ACE_NTOHL (0x65000000),  // name = Complex64Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          64U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex64Seq),
    (char *) &_oc_TP_Test_Complex64Seq,
    0,
    sizeof (TP_Test::Complex64Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64Seq =
    &_tc_TAO_tc_TP_Test_Complex64Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex64TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex64TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex64TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex64TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex64TypeSupportInterface>::tao_release (
    TP_Test::Complex64TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex64TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex64TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex64TypeSupportInterface>::tao_marshal (
    TP_Test::Complex64TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex64TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex64TypeSupportInterface::Complex64TypeSupportInterface (void)
{}

TP_Test::Complex64TypeSupportInterface::~Complex64TypeSupportInterface (void)
{}

void 
TP_Test::Complex64TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex64TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex64TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex64TypeSupportInterface_ptr
TP_Test::Complex64TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64TypeSupportInterface::_nil ();
    }
  
  Complex64TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex64TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex64TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex64TypeSupportInterface_ptr
TP_Test::Complex64TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64TypeSupportInterface::_nil ();
    }
  
  Complex64TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex64TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex64TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex64TypeSupportInterface_ptr
TP_Test::Complex64TypeSupportInterface::_duplicate (Complex64TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex64TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex64TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex64TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex64TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex64TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex64TypeSupportInterface:1.0
    30,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34547970), 
  ACE_NTOHL (0x65537570), 
  ACE_NTOHL (0x706f7274), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = Complex64TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex64TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex64TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex64TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex64TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex64DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex64DataWriter>::tao_duplicate (
    TP_Test::Complex64DataWriter_ptr p
  )
{
  return TP_Test::Complex64DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex64DataWriter>::tao_release (
    TP_Test::Complex64DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex64DataWriter>::tao_nil (void)
{
  return TP_Test::Complex64DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex64DataWriter>::tao_marshal (
    TP_Test::Complex64DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex64DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex64DataWriter::Complex64DataWriter (void)
{}

TP_Test::Complex64DataWriter::~Complex64DataWriter (void)
{}

void 
TP_Test::Complex64DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex64DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex64DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex64DataWriter_ptr
TP_Test::Complex64DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64DataWriter::_nil ();
    }
  
  Complex64DataWriter_ptr proxy =
    dynamic_cast<Complex64DataWriter_ptr> (_tao_objref);
  
  return Complex64DataWriter::_duplicate (proxy);
}

TP_Test::Complex64DataWriter_ptr
TP_Test::Complex64DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64DataWriter::_nil ();
    }
  
  Complex64DataWriter_ptr proxy =
    dynamic_cast<Complex64DataWriter_ptr> (_tao_objref);
  
  return Complex64DataWriter::_duplicate (proxy);
}

TP_Test::Complex64DataWriter_ptr
TP_Test::Complex64DataWriter::_duplicate (Complex64DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex64DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex64DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex64DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex64DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex64DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x7465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex64DataWriter:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61577269), 
  ACE_NTOHL (0x74657200),  // name = Complex64DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex64DataWriter),
    (char *) &_oc_TP_Test_Complex64DataWriter,
    0,
    sizeof (TP_Test::Complex64DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64DataWriter =
    &_tc_TAO_tc_TP_Test_Complex64DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex64DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex64DataReader>::tao_duplicate (
    TP_Test::Complex64DataReader_ptr p
  )
{
  return TP_Test::Complex64DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex64DataReader>::tao_release (
    TP_Test::Complex64DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex64DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex64DataReader>::tao_nil (void)
{
  return TP_Test::Complex64DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex64DataReader>::tao_marshal (
    TP_Test::Complex64DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex64DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex64DataReader::Complex64DataReader (void)
{}

TP_Test::Complex64DataReader::~Complex64DataReader (void)
{}

void 
TP_Test::Complex64DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex64DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex64DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex64DataReader_ptr
TP_Test::Complex64DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64DataReader::_nil ();
    }
  
  Complex64DataReader_ptr proxy =
    dynamic_cast<Complex64DataReader_ptr> (_tao_objref);
  
  return Complex64DataReader::_duplicate (proxy);
}

TP_Test::Complex64DataReader_ptr
TP_Test::Complex64DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex64DataReader::_nil ();
    }
  
  Complex64DataReader_ptr proxy =
    dynamic_cast<Complex64DataReader_ptr> (_tao_objref);
  
  return Complex64DataReader::_duplicate (proxy);
}

TP_Test::Complex64DataReader_ptr
TP_Test::Complex64DataReader::_duplicate (Complex64DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex64DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex64DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex64DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex64DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex64DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex64DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x6465723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex64DataReader:1.0
    20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657836), 
  ACE_NTOHL (0x34446174), 
  ACE_NTOHL (0x61526561), 
  ACE_NTOHL (0x64657200),  // name = Complex64DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex64DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex64DataReader),
    (char *) &_oc_TP_Test_Complex64DataReader,
    0,
    sizeof (TP_Test::Complex64DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex64DataReader =
    &_tc_TAO_tc_TP_Test_Complex64DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX128SEQ_CS_)
#define _TP_TEST_COMPLEX128SEQ_CS_

TP_Test::Complex128Seq::Complex128Seq (void)
{}

TP_Test::Complex128Seq::Complex128Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex128
      >
    (max)
{}

TP_Test::Complex128Seq::Complex128Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex128 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex128
      >
    (max, length, buffer, release)
{}

TP_Test::Complex128Seq::Complex128Seq (
    const Complex128Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex128
      >
    (seq)
{}

TP_Test::Complex128Seq::~Complex128Seq (void)
{}

void TP_Test::Complex128Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex128Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex128Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex128Seq:1.0
    14,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385365), 
  ACE_NTOHL (0x71000000),  // name = Complex128Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x32383a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128:1.0
            11,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x32380000),  // name = Complex128
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x32385365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128Sequence:1.0
                19,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x32385365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Complex128Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          128U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex128Seq),
    (char *) &_oc_TP_Test_Complex128Seq,
    0,
    sizeof (TP_Test::Complex128Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128Seq =
    &_tc_TAO_tc_TP_Test_Complex128Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex128TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex128TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex128TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex128TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex128TypeSupportInterface>::tao_release (
    TP_Test::Complex128TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex128TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex128TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex128TypeSupportInterface>::tao_marshal (
    TP_Test::Complex128TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex128TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex128TypeSupportInterface::Complex128TypeSupportInterface (void)
{}

TP_Test::Complex128TypeSupportInterface::~Complex128TypeSupportInterface (void)
{}

void 
TP_Test::Complex128TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex128TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex128TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex128TypeSupportInterface_ptr
TP_Test::Complex128TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128TypeSupportInterface::_nil ();
    }
  
  Complex128TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex128TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex128TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex128TypeSupportInterface_ptr
TP_Test::Complex128TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128TypeSupportInterface::_nil ();
    }
  
  Complex128TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex128TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex128TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex128TypeSupportInterface_ptr
TP_Test::Complex128TypeSupportInterface::_duplicate (Complex128TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex128TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex128TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex128TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex128TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex128TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex128TypeSupportInterface:1.0
    31,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32385479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Complex128TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex128TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex128TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex128TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex128TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex128DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex128DataWriter>::tao_duplicate (
    TP_Test::Complex128DataWriter_ptr p
  )
{
  return TP_Test::Complex128DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex128DataWriter>::tao_release (
    TP_Test::Complex128DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex128DataWriter>::tao_nil (void)
{
  return TP_Test::Complex128DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex128DataWriter>::tao_marshal (
    TP_Test::Complex128DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex128DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex128DataWriter::Complex128DataWriter (void)
{}

TP_Test::Complex128DataWriter::~Complex128DataWriter (void)
{}

void 
TP_Test::Complex128DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex128DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex128DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex128DataWriter_ptr
TP_Test::Complex128DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128DataWriter::_nil ();
    }
  
  Complex128DataWriter_ptr proxy =
    dynamic_cast<Complex128DataWriter_ptr> (_tao_objref);
  
  return Complex128DataWriter::_duplicate (proxy);
}

TP_Test::Complex128DataWriter_ptr
TP_Test::Complex128DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128DataWriter::_nil ();
    }
  
  Complex128DataWriter_ptr proxy =
    dynamic_cast<Complex128DataWriter_ptr> (_tao_objref);
  
  return Complex128DataWriter::_duplicate (proxy);
}

TP_Test::Complex128DataWriter_ptr
TP_Test::Complex128DataWriter::_duplicate (Complex128DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex128DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex128DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex128DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex128DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex128DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32384461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex128DataWriter:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32384461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Complex128DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex128DataWriter),
    (char *) &_oc_TP_Test_Complex128DataWriter,
    0,
    sizeof (TP_Test::Complex128DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128DataWriter =
    &_tc_TAO_tc_TP_Test_Complex128DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex128DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex128DataReader>::tao_duplicate (
    TP_Test::Complex128DataReader_ptr p
  )
{
  return TP_Test::Complex128DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex128DataReader>::tao_release (
    TP_Test::Complex128DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex128DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex128DataReader>::tao_nil (void)
{
  return TP_Test::Complex128DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex128DataReader>::tao_marshal (
    TP_Test::Complex128DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex128DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex128DataReader::Complex128DataReader (void)
{}

TP_Test::Complex128DataReader::~Complex128DataReader (void)
{}

void 
TP_Test::Complex128DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex128DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex128DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex128DataReader_ptr
TP_Test::Complex128DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128DataReader::_nil ();
    }
  
  Complex128DataReader_ptr proxy =
    dynamic_cast<Complex128DataReader_ptr> (_tao_objref);
  
  return Complex128DataReader::_duplicate (proxy);
}

TP_Test::Complex128DataReader_ptr
TP_Test::Complex128DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex128DataReader::_nil ();
    }
  
  Complex128DataReader_ptr proxy =
    dynamic_cast<Complex128DataReader_ptr> (_tao_objref);
  
  return Complex128DataReader::_duplicate (proxy);
}

TP_Test::Complex128DataReader_ptr
TP_Test::Complex128DataReader::_duplicate (Complex128DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex128DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex128DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex128DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex128DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex128DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex128DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32384461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex128DataReader:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x32384461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Complex128DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex128DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex128DataReader),
    (char *) &_oc_TP_Test_Complex128DataReader,
    0,
    sizeof (TP_Test::Complex128DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex128DataReader =
    &_tc_TAO_tc_TP_Test_Complex128DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX256SEQ_CS_)
#define _TP_TEST_COMPLEX256SEQ_CS_

TP_Test::Complex256Seq::Complex256Seq (void)
{}

TP_Test::Complex256Seq::Complex256Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex256
      >
    (max)
{}

TP_Test::Complex256Seq::Complex256Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex256 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex256
      >
    (max, length, buffer, release)
{}

TP_Test::Complex256Seq::Complex256Seq (
    const Complex256Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex256
      >
    (seq)
{}

TP_Test::Complex256Seq::~Complex256Seq (void)
{}

void TP_Test::Complex256Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex256Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex256Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex256Seq:1.0
    14,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365365), 
  ACE_NTOHL (0x71000000),  // name = Complex256Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657832), 
      ACE_NTOHL (0x35363a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256:1.0
            11,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657832), 
      ACE_NTOHL (0x35360000),  // name = Complex256
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657832), 
        ACE_NTOHL (0x35365365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256Sequence:1.0
                19,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657832), 
        ACE_NTOHL (0x35365365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Complex256Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          256U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex256Seq),
    (char *) &_oc_TP_Test_Complex256Seq,
    0,
    sizeof (TP_Test::Complex256Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256Seq =
    &_tc_TAO_tc_TP_Test_Complex256Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex256TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex256TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex256TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex256TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex256TypeSupportInterface>::tao_release (
    TP_Test::Complex256TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex256TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex256TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex256TypeSupportInterface>::tao_marshal (
    TP_Test::Complex256TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex256TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex256TypeSupportInterface::Complex256TypeSupportInterface (void)
{}

TP_Test::Complex256TypeSupportInterface::~Complex256TypeSupportInterface (void)
{}

void 
TP_Test::Complex256TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex256TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex256TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex256TypeSupportInterface_ptr
TP_Test::Complex256TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256TypeSupportInterface::_nil ();
    }
  
  Complex256TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex256TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex256TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex256TypeSupportInterface_ptr
TP_Test::Complex256TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256TypeSupportInterface::_nil ();
    }
  
  Complex256TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex256TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex256TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex256TypeSupportInterface_ptr
TP_Test::Complex256TypeSupportInterface::_duplicate (Complex256TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex256TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex256TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex256TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex256TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex256TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex256TypeSupportInterface:1.0
    31,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35365479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Complex256TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex256TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex256TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex256TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex256TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex256DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex256DataWriter>::tao_duplicate (
    TP_Test::Complex256DataWriter_ptr p
  )
{
  return TP_Test::Complex256DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex256DataWriter>::tao_release (
    TP_Test::Complex256DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex256DataWriter>::tao_nil (void)
{
  return TP_Test::Complex256DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex256DataWriter>::tao_marshal (
    TP_Test::Complex256DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex256DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex256DataWriter::Complex256DataWriter (void)
{}

TP_Test::Complex256DataWriter::~Complex256DataWriter (void)
{}

void 
TP_Test::Complex256DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex256DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex256DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex256DataWriter_ptr
TP_Test::Complex256DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256DataWriter::_nil ();
    }
  
  Complex256DataWriter_ptr proxy =
    dynamic_cast<Complex256DataWriter_ptr> (_tao_objref);
  
  return Complex256DataWriter::_duplicate (proxy);
}

TP_Test::Complex256DataWriter_ptr
TP_Test::Complex256DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256DataWriter::_nil ();
    }
  
  Complex256DataWriter_ptr proxy =
    dynamic_cast<Complex256DataWriter_ptr> (_tao_objref);
  
  return Complex256DataWriter::_duplicate (proxy);
}

TP_Test::Complex256DataWriter_ptr
TP_Test::Complex256DataWriter::_duplicate (Complex256DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex256DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex256DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex256DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex256DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex256DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35364461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex256DataWriter:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35364461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Complex256DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex256DataWriter),
    (char *) &_oc_TP_Test_Complex256DataWriter,
    0,
    sizeof (TP_Test::Complex256DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256DataWriter =
    &_tc_TAO_tc_TP_Test_Complex256DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex256DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex256DataReader>::tao_duplicate (
    TP_Test::Complex256DataReader_ptr p
  )
{
  return TP_Test::Complex256DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex256DataReader>::tao_release (
    TP_Test::Complex256DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex256DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex256DataReader>::tao_nil (void)
{
  return TP_Test::Complex256DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex256DataReader>::tao_marshal (
    TP_Test::Complex256DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex256DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex256DataReader::Complex256DataReader (void)
{}

TP_Test::Complex256DataReader::~Complex256DataReader (void)
{}

void 
TP_Test::Complex256DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex256DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex256DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex256DataReader_ptr
TP_Test::Complex256DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256DataReader::_nil ();
    }
  
  Complex256DataReader_ptr proxy =
    dynamic_cast<Complex256DataReader_ptr> (_tao_objref);
  
  return Complex256DataReader::_duplicate (proxy);
}

TP_Test::Complex256DataReader_ptr
TP_Test::Complex256DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex256DataReader::_nil ();
    }
  
  Complex256DataReader_ptr proxy =
    dynamic_cast<Complex256DataReader_ptr> (_tao_objref);
  
  return Complex256DataReader::_duplicate (proxy);
}

TP_Test::Complex256DataReader_ptr
TP_Test::Complex256DataReader::_duplicate (Complex256DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex256DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex256DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex256DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex256DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex256DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex256DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35364461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex256DataReader:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x35364461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Complex256DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex256DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex256DataReader),
    (char *) &_oc_TP_Test_Complex256DataReader,
    0,
    sizeof (TP_Test::Complex256DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex256DataReader =
    &_tc_TAO_tc_TP_Test_Complex256DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX512SEQ_CS_)
#define _TP_TEST_COMPLEX512SEQ_CS_

TP_Test::Complex512Seq::Complex512Seq (void)
{}

TP_Test::Complex512Seq::Complex512Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex512
      >
    (max)
{}

TP_Test::Complex512Seq::Complex512Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex512 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex512
      >
    (max, length, buffer, release)
{}

TP_Test::Complex512Seq::Complex512Seq (
    const Complex512Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex512
      >
    (seq)
{}

TP_Test::Complex512Seq::~Complex512Seq (void)
{}

void TP_Test::Complex512Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex512Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex512Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex512Seq:1.0
    14,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325365), 
  ACE_NTOHL (0x71000000),  // name = Complex512Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657835), 
      ACE_NTOHL (0x31323a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512:1.0
            11,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657835), 
      ACE_NTOHL (0x31320000),  // name = Complex512
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657835), 
        ACE_NTOHL (0x31325365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512Sequence:1.0
                19,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657835), 
        ACE_NTOHL (0x31325365), 
        ACE_NTOHL (0x7175656e), 
        ACE_NTOHL (0x63650000),  // name = Complex512Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          512U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex512Seq),
    (char *) &_oc_TP_Test_Complex512Seq,
    0,
    sizeof (TP_Test::Complex512Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512Seq =
    &_tc_TAO_tc_TP_Test_Complex512Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex512TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex512TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex512TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex512TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex512TypeSupportInterface>::tao_release (
    TP_Test::Complex512TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex512TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex512TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex512TypeSupportInterface>::tao_marshal (
    TP_Test::Complex512TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex512TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex512TypeSupportInterface::Complex512TypeSupportInterface (void)
{}

TP_Test::Complex512TypeSupportInterface::~Complex512TypeSupportInterface (void)
{}

void 
TP_Test::Complex512TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex512TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex512TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex512TypeSupportInterface_ptr
TP_Test::Complex512TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512TypeSupportInterface::_nil ();
    }
  
  Complex512TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex512TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex512TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex512TypeSupportInterface_ptr
TP_Test::Complex512TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512TypeSupportInterface::_nil ();
    }
  
  Complex512TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex512TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex512TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex512TypeSupportInterface_ptr
TP_Test::Complex512TypeSupportInterface::_duplicate (Complex512TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex512TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex512TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex512TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex512TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex512TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex512TypeSupportInterface:1.0
    31,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31325479), 
  ACE_NTOHL (0x70655375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63650000),  // name = Complex512TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex512TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex512TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex512TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex512TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex512DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex512DataWriter>::tao_duplicate (
    TP_Test::Complex512DataWriter_ptr p
  )
{
  return TP_Test::Complex512DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex512DataWriter>::tao_release (
    TP_Test::Complex512DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex512DataWriter>::tao_nil (void)
{
  return TP_Test::Complex512DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex512DataWriter>::tao_marshal (
    TP_Test::Complex512DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex512DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex512DataWriter::Complex512DataWriter (void)
{}

TP_Test::Complex512DataWriter::~Complex512DataWriter (void)
{}

void 
TP_Test::Complex512DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex512DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex512DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex512DataWriter_ptr
TP_Test::Complex512DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512DataWriter::_nil ();
    }
  
  Complex512DataWriter_ptr proxy =
    dynamic_cast<Complex512DataWriter_ptr> (_tao_objref);
  
  return Complex512DataWriter::_duplicate (proxy);
}

TP_Test::Complex512DataWriter_ptr
TP_Test::Complex512DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512DataWriter::_nil ();
    }
  
  Complex512DataWriter_ptr proxy =
    dynamic_cast<Complex512DataWriter_ptr> (_tao_objref);
  
  return Complex512DataWriter::_duplicate (proxy);
}

TP_Test::Complex512DataWriter_ptr
TP_Test::Complex512DataWriter::_duplicate (Complex512DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex512DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex512DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex512DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex512DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex512DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31324461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex512DataWriter:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31324461), 
  ACE_NTOHL (0x74615772), 
  ACE_NTOHL (0x69746572), 
  ACE_NTOHL (0x0),  // name = Complex512DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex512DataWriter),
    (char *) &_oc_TP_Test_Complex512DataWriter,
    0,
    sizeof (TP_Test::Complex512DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512DataWriter =
    &_tc_TAO_tc_TP_Test_Complex512DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex512DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex512DataReader>::tao_duplicate (
    TP_Test::Complex512DataReader_ptr p
  )
{
  return TP_Test::Complex512DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex512DataReader>::tao_release (
    TP_Test::Complex512DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex512DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex512DataReader>::tao_nil (void)
{
  return TP_Test::Complex512DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex512DataReader>::tao_marshal (
    TP_Test::Complex512DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex512DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex512DataReader::Complex512DataReader (void)
{}

TP_Test::Complex512DataReader::~Complex512DataReader (void)
{}

void 
TP_Test::Complex512DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex512DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex512DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex512DataReader_ptr
TP_Test::Complex512DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512DataReader::_nil ();
    }
  
  Complex512DataReader_ptr proxy =
    dynamic_cast<Complex512DataReader_ptr> (_tao_objref);
  
  return Complex512DataReader::_duplicate (proxy);
}

TP_Test::Complex512DataReader_ptr
TP_Test::Complex512DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex512DataReader::_nil ();
    }
  
  Complex512DataReader_ptr proxy =
    dynamic_cast<Complex512DataReader_ptr> (_tao_objref);
  
  return Complex512DataReader::_duplicate (proxy);
}

TP_Test::Complex512DataReader_ptr
TP_Test::Complex512DataReader::_duplicate (Complex512DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex512DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex512DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex512DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex512DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex512DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex512DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31324461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex512DataReader:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657835), 
  ACE_NTOHL (0x31324461), 
  ACE_NTOHL (0x74615265), 
  ACE_NTOHL (0x61646572), 
  ACE_NTOHL (0x0),  // name = Complex512DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex512DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex512DataReader),
    (char *) &_oc_TP_Test_Complex512DataReader,
    0,
    sizeof (TP_Test::Complex512DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex512DataReader =
    &_tc_TAO_tc_TP_Test_Complex512DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX1024SEQ_CS_)
#define _TP_TEST_COMPLEX1024SEQ_CS_

TP_Test::Complex1024Seq::Complex1024Seq (void)
{}

TP_Test::Complex1024Seq::Complex1024Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex1024
      >
    (max)
{}

TP_Test::Complex1024Seq::Complex1024Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex1024 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex1024
      >
    (max, length, buffer, release)
{}

TP_Test::Complex1024Seq::Complex1024Seq (
    const Complex1024Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex1024
      >
    (seq)
{}

TP_Test::Complex1024Seq::~Complex1024Seq (void)
{}

void TP_Test::Complex1024Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex1024Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex1024Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323453), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex1024Seq:1.0
    15,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323453), 
  ACE_NTOHL (0x65710000),  // name = Complex1024Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x3032343a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024:1.0
            12,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x30323400),  // name = Complex1024
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x30323453), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024Sequence:1.0
                20,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x30323453), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Complex1024Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          1024U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex1024Seq),
    (char *) &_oc_TP_Test_Complex1024Seq,
    0,
    sizeof (TP_Test::Complex1024Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024Seq =
    &_tc_TAO_tc_TP_Test_Complex1024Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex1024TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex1024TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex1024TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex1024TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex1024TypeSupportInterface>::tao_release (
    TP_Test::Complex1024TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex1024TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex1024TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex1024TypeSupportInterface>::tao_marshal (
    TP_Test::Complex1024TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex1024TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex1024TypeSupportInterface::Complex1024TypeSupportInterface (void)
{}

TP_Test::Complex1024TypeSupportInterface::~Complex1024TypeSupportInterface (void)
{}

void 
TP_Test::Complex1024TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex1024TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex1024TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex1024TypeSupportInterface_ptr
TP_Test::Complex1024TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024TypeSupportInterface::_nil ();
    }
  
  Complex1024TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex1024TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex1024TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex1024TypeSupportInterface_ptr
TP_Test::Complex1024TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024TypeSupportInterface::_nil ();
    }
  
  Complex1024TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex1024TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex1024TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex1024TypeSupportInterface_ptr
TP_Test::Complex1024TypeSupportInterface::_duplicate (Complex1024TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex1024TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex1024TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex1024TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex1024TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex1024TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323454), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex1024TypeSupportInterface:1.0
    32,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323454), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Complex1024TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex1024TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex1024TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex1024TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex1024TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex1024DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex1024DataWriter>::tao_duplicate (
    TP_Test::Complex1024DataWriter_ptr p
  )
{
  return TP_Test::Complex1024DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex1024DataWriter>::tao_release (
    TP_Test::Complex1024DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex1024DataWriter>::tao_nil (void)
{
  return TP_Test::Complex1024DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex1024DataWriter>::tao_marshal (
    TP_Test::Complex1024DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex1024DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex1024DataWriter::Complex1024DataWriter (void)
{}

TP_Test::Complex1024DataWriter::~Complex1024DataWriter (void)
{}

void 
TP_Test::Complex1024DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex1024DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex1024DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex1024DataWriter_ptr
TP_Test::Complex1024DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024DataWriter::_nil ();
    }
  
  Complex1024DataWriter_ptr proxy =
    dynamic_cast<Complex1024DataWriter_ptr> (_tao_objref);
  
  return Complex1024DataWriter::_duplicate (proxy);
}

TP_Test::Complex1024DataWriter_ptr
TP_Test::Complex1024DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024DataWriter::_nil ();
    }
  
  Complex1024DataWriter_ptr proxy =
    dynamic_cast<Complex1024DataWriter_ptr> (_tao_objref);
  
  return Complex1024DataWriter::_duplicate (proxy);
}

TP_Test::Complex1024DataWriter_ptr
TP_Test::Complex1024DataWriter::_duplicate (Complex1024DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex1024DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex1024DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex1024DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex1024DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex1024DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323444), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex1024DataWriter:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323444), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Complex1024DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex1024DataWriter),
    (char *) &_oc_TP_Test_Complex1024DataWriter,
    0,
    sizeof (TP_Test::Complex1024DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024DataWriter =
    &_tc_TAO_tc_TP_Test_Complex1024DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex1024DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex1024DataReader>::tao_duplicate (
    TP_Test::Complex1024DataReader_ptr p
  )
{
  return TP_Test::Complex1024DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex1024DataReader>::tao_release (
    TP_Test::Complex1024DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex1024DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex1024DataReader>::tao_nil (void)
{
  return TP_Test::Complex1024DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex1024DataReader>::tao_marshal (
    TP_Test::Complex1024DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex1024DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex1024DataReader::Complex1024DataReader (void)
{}

TP_Test::Complex1024DataReader::~Complex1024DataReader (void)
{}

void 
TP_Test::Complex1024DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex1024DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex1024DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex1024DataReader_ptr
TP_Test::Complex1024DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024DataReader::_nil ();
    }
  
  Complex1024DataReader_ptr proxy =
    dynamic_cast<Complex1024DataReader_ptr> (_tao_objref);
  
  return Complex1024DataReader::_duplicate (proxy);
}

TP_Test::Complex1024DataReader_ptr
TP_Test::Complex1024DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex1024DataReader::_nil ();
    }
  
  Complex1024DataReader_ptr proxy =
    dynamic_cast<Complex1024DataReader_ptr> (_tao_objref);
  
  return Complex1024DataReader::_duplicate (proxy);
}

TP_Test::Complex1024DataReader_ptr
TP_Test::Complex1024DataReader::_duplicate (Complex1024DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex1024DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex1024DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex1024DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex1024DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex1024DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex1024DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323444), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex1024DataReader:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x30323444), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Complex1024DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex1024DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex1024DataReader),
    (char *) &_oc_TP_Test_Complex1024DataReader,
    0,
    sizeof (TP_Test::Complex1024DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex1024DataReader =
    &_tc_TAO_tc_TP_Test_Complex1024DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX2048SEQ_CS_)
#define _TP_TEST_COMPLEX2048SEQ_CS_

TP_Test::Complex2048Seq::Complex2048Seq (void)
{}

TP_Test::Complex2048Seq::Complex2048Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex2048
      >
    (max)
{}

TP_Test::Complex2048Seq::Complex2048Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex2048 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex2048
      >
    (max, length, buffer, release)
{}

TP_Test::Complex2048Seq::Complex2048Seq (
    const Complex2048Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex2048
      >
    (seq)
{}

TP_Test::Complex2048Seq::~Complex2048Seq (void)
{}

void TP_Test::Complex2048Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex2048Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex2048Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343853), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex2048Seq:1.0
    15,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343853), 
  ACE_NTOHL (0x65710000),  // name = Complex2048Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657832), 
      ACE_NTOHL (0x3034383a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048:1.0
            12,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657832), 
      ACE_NTOHL (0x30343800),  // name = Complex2048
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657832), 
        ACE_NTOHL (0x30343853), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048Sequence:1.0
                20,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657832), 
        ACE_NTOHL (0x30343853), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Complex2048Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          2048U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex2048Seq),
    (char *) &_oc_TP_Test_Complex2048Seq,
    0,
    sizeof (TP_Test::Complex2048Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048Seq =
    &_tc_TAO_tc_TP_Test_Complex2048Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex2048TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex2048TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex2048TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex2048TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex2048TypeSupportInterface>::tao_release (
    TP_Test::Complex2048TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex2048TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex2048TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex2048TypeSupportInterface>::tao_marshal (
    TP_Test::Complex2048TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex2048TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex2048TypeSupportInterface::Complex2048TypeSupportInterface (void)
{}

TP_Test::Complex2048TypeSupportInterface::~Complex2048TypeSupportInterface (void)
{}

void 
TP_Test::Complex2048TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex2048TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex2048TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex2048TypeSupportInterface_ptr
TP_Test::Complex2048TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048TypeSupportInterface::_nil ();
    }
  
  Complex2048TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex2048TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex2048TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex2048TypeSupportInterface_ptr
TP_Test::Complex2048TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048TypeSupportInterface::_nil ();
    }
  
  Complex2048TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex2048TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex2048TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex2048TypeSupportInterface_ptr
TP_Test::Complex2048TypeSupportInterface::_duplicate (Complex2048TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex2048TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex2048TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex2048TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex2048TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex2048TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343854), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex2048TypeSupportInterface:1.0
    32,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343854), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Complex2048TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex2048TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex2048TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex2048TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex2048TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex2048DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex2048DataWriter>::tao_duplicate (
    TP_Test::Complex2048DataWriter_ptr p
  )
{
  return TP_Test::Complex2048DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex2048DataWriter>::tao_release (
    TP_Test::Complex2048DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex2048DataWriter>::tao_nil (void)
{
  return TP_Test::Complex2048DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex2048DataWriter>::tao_marshal (
    TP_Test::Complex2048DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex2048DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex2048DataWriter::Complex2048DataWriter (void)
{}

TP_Test::Complex2048DataWriter::~Complex2048DataWriter (void)
{}

void 
TP_Test::Complex2048DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex2048DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex2048DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex2048DataWriter_ptr
TP_Test::Complex2048DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048DataWriter::_nil ();
    }
  
  Complex2048DataWriter_ptr proxy =
    dynamic_cast<Complex2048DataWriter_ptr> (_tao_objref);
  
  return Complex2048DataWriter::_duplicate (proxy);
}

TP_Test::Complex2048DataWriter_ptr
TP_Test::Complex2048DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048DataWriter::_nil ();
    }
  
  Complex2048DataWriter_ptr proxy =
    dynamic_cast<Complex2048DataWriter_ptr> (_tao_objref);
  
  return Complex2048DataWriter::_duplicate (proxy);
}

TP_Test::Complex2048DataWriter_ptr
TP_Test::Complex2048DataWriter::_duplicate (Complex2048DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex2048DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex2048DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex2048DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex2048DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex2048DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343844), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex2048DataWriter:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343844), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Complex2048DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex2048DataWriter),
    (char *) &_oc_TP_Test_Complex2048DataWriter,
    0,
    sizeof (TP_Test::Complex2048DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048DataWriter =
    &_tc_TAO_tc_TP_Test_Complex2048DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex2048DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex2048DataReader>::tao_duplicate (
    TP_Test::Complex2048DataReader_ptr p
  )
{
  return TP_Test::Complex2048DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex2048DataReader>::tao_release (
    TP_Test::Complex2048DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex2048DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex2048DataReader>::tao_nil (void)
{
  return TP_Test::Complex2048DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex2048DataReader>::tao_marshal (
    TP_Test::Complex2048DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex2048DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex2048DataReader::Complex2048DataReader (void)
{}

TP_Test::Complex2048DataReader::~Complex2048DataReader (void)
{}

void 
TP_Test::Complex2048DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex2048DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex2048DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex2048DataReader_ptr
TP_Test::Complex2048DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048DataReader::_nil ();
    }
  
  Complex2048DataReader_ptr proxy =
    dynamic_cast<Complex2048DataReader_ptr> (_tao_objref);
  
  return Complex2048DataReader::_duplicate (proxy);
}

TP_Test::Complex2048DataReader_ptr
TP_Test::Complex2048DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex2048DataReader::_nil ();
    }
  
  Complex2048DataReader_ptr proxy =
    dynamic_cast<Complex2048DataReader_ptr> (_tao_objref);
  
  return Complex2048DataReader::_duplicate (proxy);
}

TP_Test::Complex2048DataReader_ptr
TP_Test::Complex2048DataReader::_duplicate (Complex2048DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex2048DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex2048DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex2048DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex2048DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex2048DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex2048DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343844), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex2048DataReader:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657832), 
  ACE_NTOHL (0x30343844), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Complex2048DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex2048DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex2048DataReader),
    (char *) &_oc_TP_Test_Complex2048DataReader,
    0,
    sizeof (TP_Test::Complex2048DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex2048DataReader =
    &_tc_TAO_tc_TP_Test_Complex2048DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX4096SEQ_CS_)
#define _TP_TEST_COMPLEX4096SEQ_CS_

TP_Test::Complex4096Seq::Complex4096Seq (void)
{}

TP_Test::Complex4096Seq::Complex4096Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4096
      >
    (max)
{}

TP_Test::Complex4096Seq::Complex4096Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex4096 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4096
      >
    (max, length, buffer, release)
{}

TP_Test::Complex4096Seq::Complex4096Seq (
    const Complex4096Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex4096
      >
    (seq)
{}

TP_Test::Complex4096Seq::~Complex4096Seq (void)
{}

void TP_Test::Complex4096Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex4096Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex4096Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex4096Seq:1.0
    15,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393653), 
  ACE_NTOHL (0x65710000),  // name = Complex4096Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657834), 
      ACE_NTOHL (0x3039363a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096:1.0
            12,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657834), 
      ACE_NTOHL (0x30393600),  // name = Complex4096
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657834), 
        ACE_NTOHL (0x30393653), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096Sequence:1.0
                20,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657834), 
        ACE_NTOHL (0x30393653), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Complex4096Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          4096U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex4096Seq),
    (char *) &_oc_TP_Test_Complex4096Seq,
    0,
    sizeof (TP_Test::Complex4096Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096Seq =
    &_tc_TAO_tc_TP_Test_Complex4096Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4096TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex4096TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex4096TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex4096TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4096TypeSupportInterface>::tao_release (
    TP_Test::Complex4096TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex4096TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex4096TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4096TypeSupportInterface>::tao_marshal (
    TP_Test::Complex4096TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4096TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4096TypeSupportInterface::Complex4096TypeSupportInterface (void)
{}

TP_Test::Complex4096TypeSupportInterface::~Complex4096TypeSupportInterface (void)
{}

void 
TP_Test::Complex4096TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4096TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex4096TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4096TypeSupportInterface_ptr
TP_Test::Complex4096TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096TypeSupportInterface::_nil ();
    }
  
  Complex4096TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex4096TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex4096TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex4096TypeSupportInterface_ptr
TP_Test::Complex4096TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096TypeSupportInterface::_nil ();
    }
  
  Complex4096TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex4096TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex4096TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex4096TypeSupportInterface_ptr
TP_Test::Complex4096TypeSupportInterface::_duplicate (Complex4096TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4096TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4096TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4096TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4096TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex4096TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393654), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex4096TypeSupportInterface:1.0
    32,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393654), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Complex4096TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4096TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex4096TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex4096TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex4096TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4096DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex4096DataWriter>::tao_duplicate (
    TP_Test::Complex4096DataWriter_ptr p
  )
{
  return TP_Test::Complex4096DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4096DataWriter>::tao_release (
    TP_Test::Complex4096DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex4096DataWriter>::tao_nil (void)
{
  return TP_Test::Complex4096DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4096DataWriter>::tao_marshal (
    TP_Test::Complex4096DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4096DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4096DataWriter::Complex4096DataWriter (void)
{}

TP_Test::Complex4096DataWriter::~Complex4096DataWriter (void)
{}

void 
TP_Test::Complex4096DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4096DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex4096DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4096DataWriter_ptr
TP_Test::Complex4096DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096DataWriter::_nil ();
    }
  
  Complex4096DataWriter_ptr proxy =
    dynamic_cast<Complex4096DataWriter_ptr> (_tao_objref);
  
  return Complex4096DataWriter::_duplicate (proxy);
}

TP_Test::Complex4096DataWriter_ptr
TP_Test::Complex4096DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096DataWriter::_nil ();
    }
  
  Complex4096DataWriter_ptr proxy =
    dynamic_cast<Complex4096DataWriter_ptr> (_tao_objref);
  
  return Complex4096DataWriter::_duplicate (proxy);
}

TP_Test::Complex4096DataWriter_ptr
TP_Test::Complex4096DataWriter::_duplicate (Complex4096DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4096DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4096DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4096DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4096DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex4096DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393644), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex4096DataWriter:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393644), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Complex4096DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4096DataWriter),
    (char *) &_oc_TP_Test_Complex4096DataWriter,
    0,
    sizeof (TP_Test::Complex4096DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096DataWriter =
    &_tc_TAO_tc_TP_Test_Complex4096DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex4096DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex4096DataReader>::tao_duplicate (
    TP_Test::Complex4096DataReader_ptr p
  )
{
  return TP_Test::Complex4096DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex4096DataReader>::tao_release (
    TP_Test::Complex4096DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex4096DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex4096DataReader>::tao_nil (void)
{
  return TP_Test::Complex4096DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex4096DataReader>::tao_marshal (
    TP_Test::Complex4096DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex4096DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex4096DataReader::Complex4096DataReader (void)
{}

TP_Test::Complex4096DataReader::~Complex4096DataReader (void)
{}

void 
TP_Test::Complex4096DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex4096DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex4096DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex4096DataReader_ptr
TP_Test::Complex4096DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096DataReader::_nil ();
    }
  
  Complex4096DataReader_ptr proxy =
    dynamic_cast<Complex4096DataReader_ptr> (_tao_objref);
  
  return Complex4096DataReader::_duplicate (proxy);
}

TP_Test::Complex4096DataReader_ptr
TP_Test::Complex4096DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex4096DataReader::_nil ();
    }
  
  Complex4096DataReader_ptr proxy =
    dynamic_cast<Complex4096DataReader_ptr> (_tao_objref);
  
  return Complex4096DataReader::_duplicate (proxy);
}

TP_Test::Complex4096DataReader_ptr
TP_Test::Complex4096DataReader::_duplicate (Complex4096DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex4096DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex4096DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex4096DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex4096DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex4096DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex4096DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393644), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex4096DataReader:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657834), 
  ACE_NTOHL (0x30393644), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Complex4096DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex4096DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex4096DataReader),
    (char *) &_oc_TP_Test_Complex4096DataReader,
    0,
    sizeof (TP_Test::Complex4096DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex4096DataReader =
    &_tc_TAO_tc_TP_Test_Complex4096DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX8192SEQ_CS_)
#define _TP_TEST_COMPLEX8192SEQ_CS_

TP_Test::Complex8192Seq::Complex8192Seq (void)
{}

TP_Test::Complex8192Seq::Complex8192Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8192
      >
    (max)
{}

TP_Test::Complex8192Seq::Complex8192Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex8192 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8192
      >
    (max, length, buffer, release)
{}

TP_Test::Complex8192Seq::Complex8192Seq (
    const Complex8192Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex8192
      >
    (seq)
{}

TP_Test::Complex8192Seq::~Complex8192Seq (void)
{}

void TP_Test::Complex8192Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex8192Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex8192Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393253), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex8192Seq:1.0
    15,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393253), 
  ACE_NTOHL (0x65710000),  // name = Complex8192Seq
    CORBA::tk_sequence, // typecode kind
  444, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    428, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657838), 
      ACE_NTOHL (0x3139323a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192:1.0
            12,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657838), 
      ACE_NTOHL (0x31393200),  // name = Complex8192
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      352, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657838), 
        ACE_NTOHL (0x31393253), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e63653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192Sequence:1.0
                20,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657838), 
        ACE_NTOHL (0x31393253), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = Complex8192Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          8192U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex8192Seq),
    (char *) &_oc_TP_Test_Complex8192Seq,
    0,
    sizeof (TP_Test::Complex8192Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192Seq =
    &_tc_TAO_tc_TP_Test_Complex8192Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8192TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex8192TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex8192TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex8192TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8192TypeSupportInterface>::tao_release (
    TP_Test::Complex8192TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex8192TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex8192TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8192TypeSupportInterface>::tao_marshal (
    TP_Test::Complex8192TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8192TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8192TypeSupportInterface::Complex8192TypeSupportInterface (void)
{}

TP_Test::Complex8192TypeSupportInterface::~Complex8192TypeSupportInterface (void)
{}

void 
TP_Test::Complex8192TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8192TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex8192TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8192TypeSupportInterface_ptr
TP_Test::Complex8192TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192TypeSupportInterface::_nil ();
    }
  
  Complex8192TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex8192TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex8192TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex8192TypeSupportInterface_ptr
TP_Test::Complex8192TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192TypeSupportInterface::_nil ();
    }
  
  Complex8192TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex8192TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex8192TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex8192TypeSupportInterface_ptr
TP_Test::Complex8192TypeSupportInterface::_duplicate (Complex8192TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8192TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8192TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8192TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8192TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex8192TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393254), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x6163653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex8192TypeSupportInterface:1.0
    32,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393254), 
  ACE_NTOHL (0x79706553), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x7274496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636500),  // name = Complex8192TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8192TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex8192TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex8192TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex8192TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8192DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex8192DataWriter>::tao_duplicate (
    TP_Test::Complex8192DataWriter_ptr p
  )
{
  return TP_Test::Complex8192DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8192DataWriter>::tao_release (
    TP_Test::Complex8192DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex8192DataWriter>::tao_nil (void)
{
  return TP_Test::Complex8192DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8192DataWriter>::tao_marshal (
    TP_Test::Complex8192DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8192DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8192DataWriter::Complex8192DataWriter (void)
{}

TP_Test::Complex8192DataWriter::~Complex8192DataWriter (void)
{}

void 
TP_Test::Complex8192DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8192DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex8192DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8192DataWriter_ptr
TP_Test::Complex8192DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192DataWriter::_nil ();
    }
  
  Complex8192DataWriter_ptr proxy =
    dynamic_cast<Complex8192DataWriter_ptr> (_tao_objref);
  
  return Complex8192DataWriter::_duplicate (proxy);
}

TP_Test::Complex8192DataWriter_ptr
TP_Test::Complex8192DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192DataWriter::_nil ();
    }
  
  Complex8192DataWriter_ptr proxy =
    dynamic_cast<Complex8192DataWriter_ptr> (_tao_objref);
  
  return Complex8192DataWriter::_duplicate (proxy);
}

TP_Test::Complex8192DataWriter_ptr
TP_Test::Complex8192DataWriter::_duplicate (Complex8192DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8192DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8192DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8192DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8192DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex8192DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393244), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex8192DataWriter:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393244), 
  ACE_NTOHL (0x61746157), 
  ACE_NTOHL (0x72697465), 
  ACE_NTOHL (0x72000000),  // name = Complex8192DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8192DataWriter),
    (char *) &_oc_TP_Test_Complex8192DataWriter,
    0,
    sizeof (TP_Test::Complex8192DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192DataWriter =
    &_tc_TAO_tc_TP_Test_Complex8192DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex8192DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex8192DataReader>::tao_duplicate (
    TP_Test::Complex8192DataReader_ptr p
  )
{
  return TP_Test::Complex8192DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex8192DataReader>::tao_release (
    TP_Test::Complex8192DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex8192DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex8192DataReader>::tao_nil (void)
{
  return TP_Test::Complex8192DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex8192DataReader>::tao_marshal (
    TP_Test::Complex8192DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex8192DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex8192DataReader::Complex8192DataReader (void)
{}

TP_Test::Complex8192DataReader::~Complex8192DataReader (void)
{}

void 
TP_Test::Complex8192DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex8192DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex8192DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex8192DataReader_ptr
TP_Test::Complex8192DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192DataReader::_nil ();
    }
  
  Complex8192DataReader_ptr proxy =
    dynamic_cast<Complex8192DataReader_ptr> (_tao_objref);
  
  return Complex8192DataReader::_duplicate (proxy);
}

TP_Test::Complex8192DataReader_ptr
TP_Test::Complex8192DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex8192DataReader::_nil ();
    }
  
  Complex8192DataReader_ptr proxy =
    dynamic_cast<Complex8192DataReader_ptr> (_tao_objref);
  
  return Complex8192DataReader::_duplicate (proxy);
}

TP_Test::Complex8192DataReader_ptr
TP_Test::Complex8192DataReader::_duplicate (Complex8192DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex8192DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex8192DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex8192DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex8192DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex8192DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex8192DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393244), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Complex8192DataReader:1.0
    22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657838), 
  ACE_NTOHL (0x31393244), 
  ACE_NTOHL (0x61746152), 
  ACE_NTOHL (0x65616465), 
  ACE_NTOHL (0x72000000),  // name = Complex8192DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex8192DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex8192DataReader),
    (char *) &_oc_TP_Test_Complex8192DataReader,
    0,
    sizeof (TP_Test::Complex8192DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex8192DataReader =
    &_tc_TAO_tc_TP_Test_Complex8192DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_TP_TEST_COMPLEX16384SEQ_CS_)
#define _TP_TEST_COMPLEX16384SEQ_CS_

TP_Test::Complex16384Seq::Complex16384Seq (void)
{}

TP_Test::Complex16384Seq::Complex16384Seq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16384
      >
    (max)
{}

TP_Test::Complex16384Seq::Complex16384Seq (
    CORBA::ULong max,
    CORBA::ULong length,
    TP_Test::Complex16384 * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16384
      >
    (max, length, buffer, release)
{}

TP_Test::Complex16384Seq::Complex16384Seq (
    const Complex16384Seq &seq
  )
  : TAO_Unbounded_Sequence<
        TP_Test::Complex16384
      >
    (seq)
{}

TP_Test::Complex16384Seq::~Complex16384Seq (void)
{}

void TP_Test::Complex16384Seq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  Complex16384Seq * _tao_tmp_pointer =
    ACE_static_cast (Complex16384Seq *, _tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384Seq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:TP_Test/Complex16384Seq:1.0
    16,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x53657100),  // name = Complex16384Seq
    CORBA::tk_sequence, // typecode kind
  460, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    444, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x54505f54), 
      ACE_NTOHL (0x6573742f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x36333834), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384:1.0
            13,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6c657831), 
      ACE_NTOHL (0x36333834), 
      ACE_NTOHL (0x0),  // name = Complex16384
      1, // member count
            5,
      ACE_NTOHL (0x64617461), 
      ACE_NTOHL (0x0),  // name = data
            CORBA::tk_alias, // typecode kind for typedefs
      360, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x54505f54), 
        ACE_NTOHL (0x6573742f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x36333834), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384Sequence:1.0
                21,
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6c657831), 
        ACE_NTOHL (0x36333834), 
        ACE_NTOHL (0x53657175), 
        ACE_NTOHL (0x656e6365), 
        ACE_NTOHL (0x0),  // name = Complex16384Sequence
                CORBA::tk_sequence, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          260, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            22,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x54505f54), 
            ACE_NTOHL (0x6573742f), 
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x723a312e), 
            ACE_NTOHL (0x30000000),  // repository ID = IDL:TP_Test/Outer:1.0
                        6,
            ACE_NTOHL (0x4f757465), 
            ACE_NTOHL (0x72000000),  // name = Outer
            2, // member count
                        7,
            ACE_NTOHL (0x6c656e67), 
            ACE_NTOHL (0x74680000),  // name = length
                        CORBA::tk_long,

            14,
            ACE_NTOHL (0x6e657374), 
            ACE_NTOHL (0x65645f6d), 
            ACE_NTOHL (0x656d6265), 
            ACE_NTOHL (0x72000000),  // name = nested_member
                        CORBA::tk_alias, // typecode kind for typedefs
            168, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x54505f54), 
              ACE_NTOHL (0x6573742f), 
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63653a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/NestedSequence:1.0
                            15,
              ACE_NTOHL (0x4e657374), 
              ACE_NTOHL (0x65645365), 
              ACE_NTOHL (0x7175656e), 
              ACE_NTOHL (0x63650000),  // name = NestedSequence
                            CORBA::tk_sequence, // typecode kind
              100, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                CORBA::tk_struct, // typecode kind
                84, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  23,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x54505f54), 
                  ACE_NTOHL (0x6573742f), 
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65643a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Nested:1.0
                                    7,
                  ACE_NTOHL (0x4e657374), 
                  ACE_NTOHL (0x65640000),  // name = Nested
                  2, // member count
                                    5,
                  ACE_NTOHL (0x696e666f), 
                  ACE_NTOHL (0x0),  // name = info
                                    CORBA::tk_string, 
                  0U, // string length
                  6,
                  ACE_NTOHL (0x696e6465), 
                  ACE_NTOHL (0x78000000),  // name = index
                                    CORBA::tk_long,


                0U,



          16384U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384Seq (
    CORBA::tk_alias,
    sizeof (_oc_TP_Test_Complex16384Seq),
    (char *) &_oc_TP_Test_Complex16384Seq,
    0,
    sizeof (TP_Test::Complex16384Seq)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384Seq =
    &_tc_TAO_tc_TP_Test_Complex16384Seq;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16384TypeSupportInterface.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex16384TypeSupportInterface>::tao_duplicate (
    TP_Test::Complex16384TypeSupportInterface_ptr p
  )
{
  return TP_Test::Complex16384TypeSupportInterface::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16384TypeSupportInterface>::tao_release (
    TP_Test::Complex16384TypeSupportInterface_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384TypeSupportInterface_ptr
TAO::Objref_Traits<TP_Test::Complex16384TypeSupportInterface>::tao_nil (void)
{
  return TP_Test::Complex16384TypeSupportInterface::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16384TypeSupportInterface>::tao_marshal (
    TP_Test::Complex16384TypeSupportInterface_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16384TypeSupportInterface_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16384TypeSupportInterface::Complex16384TypeSupportInterface (void)
{}

TP_Test::Complex16384TypeSupportInterface::~Complex16384TypeSupportInterface (void)
{}

void 
TP_Test::Complex16384TypeSupportInterface::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16384TypeSupportInterface *_tao_tmp_pointer =
    ACE_static_cast (Complex16384TypeSupportInterface *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16384TypeSupportInterface_ptr
TP_Test::Complex16384TypeSupportInterface::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384TypeSupportInterface::_nil ();
    }
  
  Complex16384TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex16384TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex16384TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex16384TypeSupportInterface_ptr
TP_Test::Complex16384TypeSupportInterface::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384TypeSupportInterface::_nil ();
    }
  
  Complex16384TypeSupportInterface_ptr proxy =
    dynamic_cast<Complex16384TypeSupportInterface_ptr> (_tao_objref);
  
  return Complex16384TypeSupportInterface::_duplicate (proxy);
}

TP_Test::Complex16384TypeSupportInterface_ptr
TP_Test::Complex16384TypeSupportInterface::_duplicate (Complex16384TypeSupportInterface_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16384TypeSupportInterface::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/TypeSupport:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16384TypeSupportInterface:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16384TypeSupportInterface::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16384TypeSupportInterface:1.0";
}

CORBA::Boolean
TP_Test::Complex16384TypeSupportInterface::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384TypeSupportInterface[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:TP_Test/Complex16384TypeSupportInterface:1.0
    33,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = Complex16384TypeSupportInterface
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384TypeSupportInterface (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16384TypeSupportInterface),
    (char *) &_oc_TP_Test_Complex16384TypeSupportInterface,
    0,
    sizeof (TP_Test::Complex16384TypeSupportInterface)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384TypeSupportInterface =
    &_tc_TAO_tc_TP_Test_Complex16384TypeSupportInterface;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16384DataWriter.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex16384DataWriter>::tao_duplicate (
    TP_Test::Complex16384DataWriter_ptr p
  )
{
  return TP_Test::Complex16384DataWriter::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16384DataWriter>::tao_release (
    TP_Test::Complex16384DataWriter_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384DataWriter_ptr
TAO::Objref_Traits<TP_Test::Complex16384DataWriter>::tao_nil (void)
{
  return TP_Test::Complex16384DataWriter::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16384DataWriter>::tao_marshal (
    TP_Test::Complex16384DataWriter_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16384DataWriter_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16384DataWriter::Complex16384DataWriter (void)
{}

TP_Test::Complex16384DataWriter::~Complex16384DataWriter (void)
{}

void 
TP_Test::Complex16384DataWriter::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16384DataWriter *_tao_tmp_pointer =
    ACE_static_cast (Complex16384DataWriter *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16384DataWriter_ptr
TP_Test::Complex16384DataWriter::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384DataWriter::_nil ();
    }
  
  Complex16384DataWriter_ptr proxy =
    dynamic_cast<Complex16384DataWriter_ptr> (_tao_objref);
  
  return Complex16384DataWriter::_duplicate (proxy);
}

TP_Test::Complex16384DataWriter_ptr
TP_Test::Complex16384DataWriter::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384DataWriter::_nil ();
    }
  
  Complex16384DataWriter_ptr proxy =
    dynamic_cast<Complex16384DataWriter_ptr> (_tao_objref);
  
  return Complex16384DataWriter::_duplicate (proxy);
}

TP_Test::Complex16384DataWriter_ptr
TP_Test::Complex16384DataWriter::_duplicate (Complex16384DataWriter_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16384DataWriter::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16384DataWriter:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16384DataWriter::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16384DataWriter:1.0";
}

CORBA::Boolean
TP_Test::Complex16384DataWriter::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384DataWriter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex16384DataWriter:1.0
    23,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x57726974), 
  ACE_NTOHL (0x65720000),  // name = Complex16384DataWriter
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384DataWriter (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16384DataWriter),
    (char *) &_oc_TP_Test_Complex16384DataWriter,
    0,
    sizeof (TP_Test::Complex16384DataWriter)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384DataWriter =
    &_tc_TAO_tc_TP_Test_Complex16384DataWriter;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for TP_Test::Complex16384DataReader.

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex16384DataReader>::tao_duplicate (
    TP_Test::Complex16384DataReader_ptr p
  )
{
  return TP_Test::Complex16384DataReader::_duplicate (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
void
TAO::Objref_Traits<TP_Test::Complex16384DataReader>::tao_release (
    TP_Test::Complex16384DataReader_ptr p
  )
{
  CORBA::release (p);
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
TP_Test::Complex16384DataReader_ptr
TAO::Objref_Traits<TP_Test::Complex16384DataReader>::tao_nil (void)
{
  return TP_Test::Complex16384DataReader::_nil ();
}

ACE_TEMPLATE_CLASS_MEMBER_SPECIALIZATION
CORBA::Boolean
TAO::Objref_Traits<TP_Test::Complex16384DataReader>::tao_marshal (
    TP_Test::Complex16384DataReader_ptr p,
    TAO_OutputCDR & cdr
  )
{
  return (cdr << p);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*TP_Test__TAO_Complex16384DataReader_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

TP_Test::Complex16384DataReader::Complex16384DataReader (void)
{}

TP_Test::Complex16384DataReader::~Complex16384DataReader (void)
{}

void 
TP_Test::Complex16384DataReader::_tao_any_destructor (void *_tao_void_pointer)
{
  Complex16384DataReader *_tao_tmp_pointer =
    ACE_static_cast (Complex16384DataReader *, _tao_void_pointer);
  CORBA::release (_tao_tmp_pointer);
}

TP_Test::Complex16384DataReader_ptr
TP_Test::Complex16384DataReader::_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384DataReader::_nil ();
    }
  
  Complex16384DataReader_ptr proxy =
    dynamic_cast<Complex16384DataReader_ptr> (_tao_objref);
  
  return Complex16384DataReader::_duplicate (proxy);
}

TP_Test::Complex16384DataReader_ptr
TP_Test::Complex16384DataReader::_unchecked_narrow (
    CORBA::Object_ptr _tao_objref
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (_tao_objref))
    {
      return Complex16384DataReader::_nil ();
    }
  
  Complex16384DataReader_ptr proxy =
    dynamic_cast<Complex16384DataReader_ptr> (_tao_objref);
  
  return Complex16384DataReader::_duplicate (proxy);
}

TP_Test::Complex16384DataReader_ptr
TP_Test::Complex16384DataReader::_duplicate (Complex16384DataReader_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
TP_Test::Complex16384DataReader::_is_a (
    const char *value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/Entity:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:DDS/DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:TP_Test/Complex16384DataReader:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return 0;
    }
}

const char* TP_Test::Complex16384DataReader::_interface_repository_id (void) const
{
  return "IDL:TP_Test/Complex16384DataReader:1.0";
}

CORBA::Boolean
TP_Test::Complex16384DataReader::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_TP_Test_Complex16384DataReader[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x54505f54), 
  ACE_NTOHL (0x6573742f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:TP_Test/Complex16384DataReader:1.0
    23,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6c657831), 
  ACE_NTOHL (0x36333834), 
  ACE_NTOHL (0x44617461), 
  ACE_NTOHL (0x52656164), 
  ACE_NTOHL (0x65720000),  // name = Complex16384DataReader
  };

static CORBA::TypeCode _tc_TAO_tc_TP_Test_Complex16384DataReader (
    CORBA::tk_objref,
    sizeof (_oc_TP_Test_Complex16384DataReader),
    (char *) &_oc_TP_Test_Complex16384DataReader,
    0,
    sizeof (TP_Test::Complex16384DataReader)
  );

namespace TP_Test
{
  ::CORBA::TypeCode_ptr _tc_Complex16384DataReader =
    &_tc_TAO_tc_TP_Test_Complex16384DataReader;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::QuitMsgSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::QuitMsgSeq>::insert_copy (
      _tao_any,
      TP_Test::QuitMsgSeq::_tao_any_destructor,
      TP_Test::_tc_QuitMsgSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::QuitMsgSeq>::insert (
      _tao_any,
      TP_Test::QuitMsgSeq::_tao_any_destructor,
      TP_Test::_tc_QuitMsgSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::QuitMsgSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::QuitMsgSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::QuitMsgSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::QuitMsgSeq>::extract (
        _tao_any,
        TP_Test::QuitMsgSeq::_tao_any_destructor,
        TP_Test::_tc_QuitMsgSeq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgTypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgTypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgTypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgTypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::QuitMsgTypeSupportInterface_ptr _tao_objptr =
    TP_Test::QuitMsgTypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgTypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::QuitMsgTypeSupportInterface>::insert (
      _tao_any,
      TP_Test::QuitMsgTypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_QuitMsgTypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::QuitMsgTypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::QuitMsgTypeSupportInterface>::extract (
        _tao_any,
        TP_Test::QuitMsgTypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_QuitMsgTypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataWriter_ptr _tao_elem
  )
{
  TP_Test::QuitMsgDataWriter_ptr _tao_objptr =
    TP_Test::QuitMsgDataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::QuitMsgDataWriter>::insert (
      _tao_any,
      TP_Test::QuitMsgDataWriter::_tao_any_destructor,
      TP_Test::_tc_QuitMsgDataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::QuitMsgDataWriter>::extract (
        _tao_any,
        TP_Test::QuitMsgDataWriter::_tao_any_destructor,
        TP_Test::_tc_QuitMsgDataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::QuitMsgDataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataReader_ptr _tao_elem
  )
{
  TP_Test::QuitMsgDataReader_ptr _tao_objptr =
    TP_Test::QuitMsgDataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::QuitMsgDataReader>::insert (
      _tao_any,
      TP_Test::QuitMsgDataReader::_tao_any_destructor,
      TP_Test::_tc_QuitMsgDataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::QuitMsgDataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::QuitMsgDataReader>::extract (
        _tao_any,
        TP_Test::QuitMsgDataReader::_tao_any_destructor,
        TP_Test::_tc_QuitMsgDataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes4Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes4Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4Seq>::insert (
      _tao_any,
      TP_Test::Bytes4Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes4Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4Seq>::extract (
        _tao_any,
        TP_Test::Bytes4Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes4Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes4TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes4TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes4TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes4TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes4TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes4TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes4DataWriter_ptr _tao_objptr =
    TP_Test::Bytes4DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes4DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes4DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes4DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes4DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes4DataReader_ptr _tao_objptr =
    TP_Test::Bytes4DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4DataReader>::insert (
      _tao_any,
      TP_Test::Bytes4DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes4DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4DataReader>::extract (
        _tao_any,
        TP_Test::Bytes4DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes4DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes8Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes8Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8Seq>::insert (
      _tao_any,
      TP_Test::Bytes8Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes8Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8Seq>::extract (
        _tao_any,
        TP_Test::Bytes8Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes8Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes8TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes8TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes8TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes8TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes8TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes8TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes8DataWriter_ptr _tao_objptr =
    TP_Test::Bytes8DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes8DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes8DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes8DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes8DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes8DataReader_ptr _tao_objptr =
    TP_Test::Bytes8DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8DataReader>::insert (
      _tao_any,
      TP_Test::Bytes8DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes8DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8DataReader>::extract (
        _tao_any,
        TP_Test::Bytes8DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes8DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes16Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes16Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16Seq>::insert (
      _tao_any,
      TP_Test::Bytes16Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes16Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16Seq>::extract (
        _tao_any,
        TP_Test::Bytes16Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes16Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes16TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes16TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes16TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes16TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes16TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes16TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes16DataWriter_ptr _tao_objptr =
    TP_Test::Bytes16DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes16DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes16DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes16DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes16DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes16DataReader_ptr _tao_objptr =
    TP_Test::Bytes16DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16DataReader>::insert (
      _tao_any,
      TP_Test::Bytes16DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes16DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16DataReader>::extract (
        _tao_any,
        TP_Test::Bytes16DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes16DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes32Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes32Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes32Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes32Seq>::insert (
      _tao_any,
      TP_Test::Bytes32Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes32Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes32Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes32Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes32Seq>::extract (
        _tao_any,
        TP_Test::Bytes32Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes32Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes32TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes32TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes32TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes32TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes32TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes32TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes32TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes32TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes32DataWriter_ptr _tao_objptr =
    TP_Test::Bytes32DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes32DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes32DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes32DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes32DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes32DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes32DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes32DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes32DataReader_ptr _tao_objptr =
    TP_Test::Bytes32DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes32DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes32DataReader>::insert (
      _tao_any,
      TP_Test::Bytes32DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes32DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes32DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes32DataReader>::extract (
        _tao_any,
        TP_Test::Bytes32DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes32DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes64Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes64Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes64Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes64Seq>::insert (
      _tao_any,
      TP_Test::Bytes64Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes64Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes64Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes64Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes64Seq>::extract (
        _tao_any,
        TP_Test::Bytes64Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes64Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes64TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes64TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes64TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes64TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes64TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes64TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes64TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes64TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes64DataWriter_ptr _tao_objptr =
    TP_Test::Bytes64DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes64DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes64DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes64DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes64DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes64DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes64DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes64DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes64DataReader_ptr _tao_objptr =
    TP_Test::Bytes64DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes64DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes64DataReader>::insert (
      _tao_any,
      TP_Test::Bytes64DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes64DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes64DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes64DataReader>::extract (
        _tao_any,
        TP_Test::Bytes64DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes64DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes128Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes128Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes128Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes128Seq>::insert (
      _tao_any,
      TP_Test::Bytes128Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes128Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes128Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes128Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes128Seq>::extract (
        _tao_any,
        TP_Test::Bytes128Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes128Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes128TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes128TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes128TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes128TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes128TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes128TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes128TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes128TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes128DataWriter_ptr _tao_objptr =
    TP_Test::Bytes128DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes128DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes128DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes128DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes128DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes128DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes128DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes128DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes128DataReader_ptr _tao_objptr =
    TP_Test::Bytes128DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes128DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes128DataReader>::insert (
      _tao_any,
      TP_Test::Bytes128DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes128DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes128DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes128DataReader>::extract (
        _tao_any,
        TP_Test::Bytes128DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes128DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes256Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes256Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes256Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes256Seq>::insert (
      _tao_any,
      TP_Test::Bytes256Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes256Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes256Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes256Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes256Seq>::extract (
        _tao_any,
        TP_Test::Bytes256Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes256Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes256TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes256TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes256TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes256TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes256TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes256TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes256TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes256TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes256DataWriter_ptr _tao_objptr =
    TP_Test::Bytes256DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes256DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes256DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes256DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes256DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes256DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes256DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes256DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes256DataReader_ptr _tao_objptr =
    TP_Test::Bytes256DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes256DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes256DataReader>::insert (
      _tao_any,
      TP_Test::Bytes256DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes256DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes256DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes256DataReader>::extract (
        _tao_any,
        TP_Test::Bytes256DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes256DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes512Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes512Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes512Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes512Seq>::insert (
      _tao_any,
      TP_Test::Bytes512Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes512Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes512Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes512Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes512Seq>::extract (
        _tao_any,
        TP_Test::Bytes512Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes512Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes512TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes512TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes512TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes512TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes512TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes512TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes512TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes512TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes512DataWriter_ptr _tao_objptr =
    TP_Test::Bytes512DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes512DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes512DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes512DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes512DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes512DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes512DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes512DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes512DataReader_ptr _tao_objptr =
    TP_Test::Bytes512DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes512DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes512DataReader>::insert (
      _tao_any,
      TP_Test::Bytes512DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes512DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes512DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes512DataReader>::extract (
        _tao_any,
        TP_Test::Bytes512DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes512DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes1024Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes1024Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes1024Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Seq>::insert (
      _tao_any,
      TP_Test::Bytes1024Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes1024Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes1024Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes1024Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes1024Seq>::extract (
        _tao_any,
        TP_Test::Bytes1024Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes1024Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes1024TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes1024TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes1024TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes1024TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes1024TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes1024TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes1024TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes1024TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes1024DataWriter_ptr _tao_objptr =
    TP_Test::Bytes1024DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes1024DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes1024DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes1024DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes1024DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes1024DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes1024DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes1024DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes1024DataReader_ptr _tao_objptr =
    TP_Test::Bytes1024DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes1024DataReader>::insert (
      _tao_any,
      TP_Test::Bytes1024DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes1024DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes1024DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes1024DataReader>::extract (
        _tao_any,
        TP_Test::Bytes1024DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes1024DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes2048Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes2048Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes2048Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Seq>::insert (
      _tao_any,
      TP_Test::Bytes2048Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes2048Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes2048Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes2048Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes2048Seq>::extract (
        _tao_any,
        TP_Test::Bytes2048Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes2048Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes2048TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes2048TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes2048TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes2048TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes2048TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes2048TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes2048TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes2048TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes2048DataWriter_ptr _tao_objptr =
    TP_Test::Bytes2048DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes2048DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes2048DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes2048DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes2048DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes2048DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes2048DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes2048DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes2048DataReader_ptr _tao_objptr =
    TP_Test::Bytes2048DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes2048DataReader>::insert (
      _tao_any,
      TP_Test::Bytes2048DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes2048DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes2048DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes2048DataReader>::extract (
        _tao_any,
        TP_Test::Bytes2048DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes2048DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes4096Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes4096Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes4096Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Seq>::insert (
      _tao_any,
      TP_Test::Bytes4096Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes4096Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes4096Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes4096Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes4096Seq>::extract (
        _tao_any,
        TP_Test::Bytes4096Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes4096Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes4096TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes4096TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4096TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes4096TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes4096TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4096TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes4096TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes4096TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes4096DataWriter_ptr _tao_objptr =
    TP_Test::Bytes4096DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4096DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes4096DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes4096DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4096DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes4096DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes4096DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes4096DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes4096DataReader_ptr _tao_objptr =
    TP_Test::Bytes4096DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes4096DataReader>::insert (
      _tao_any,
      TP_Test::Bytes4096DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes4096DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes4096DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes4096DataReader>::extract (
        _tao_any,
        TP_Test::Bytes4096DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes4096DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes8192Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes8192Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes8192Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Seq>::insert (
      _tao_any,
      TP_Test::Bytes8192Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes8192Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes8192Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes8192Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes8192Seq>::extract (
        _tao_any,
        TP_Test::Bytes8192Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes8192Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes8192TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes8192TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8192TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes8192TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes8192TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8192TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes8192TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes8192TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes8192DataWriter_ptr _tao_objptr =
    TP_Test::Bytes8192DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8192DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes8192DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes8192DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8192DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes8192DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes8192DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes8192DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes8192DataReader_ptr _tao_objptr =
    TP_Test::Bytes8192DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes8192DataReader>::insert (
      _tao_any,
      TP_Test::Bytes8192DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes8192DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes8192DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes8192DataReader>::extract (
        _tao_any,
        TP_Test::Bytes8192DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes8192DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Bytes16384Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Seq>::insert_copy (
      _tao_any,
      TP_Test::Bytes16384Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes16384Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Seq>::insert (
      _tao_any,
      TP_Test::Bytes16384Seq::_tao_any_destructor,
      TP_Test::_tc_Bytes16384Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Bytes16384Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Bytes16384Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Bytes16384Seq>::extract (
        _tao_any,
        TP_Test::Bytes16384Seq::_tao_any_destructor,
        TP_Test::_tc_Bytes16384Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Bytes16384TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Bytes16384TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16384TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Bytes16384TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Bytes16384TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16384TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Bytes16384TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Bytes16384TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataWriter_ptr _tao_elem
  )
{
  TP_Test::Bytes16384DataWriter_ptr _tao_objptr =
    TP_Test::Bytes16384DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16384DataWriter>::insert (
      _tao_any,
      TP_Test::Bytes16384DataWriter::_tao_any_destructor,
      TP_Test::_tc_Bytes16384DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16384DataWriter>::extract (
        _tao_any,
        TP_Test::Bytes16384DataWriter::_tao_any_destructor,
        TP_Test::_tc_Bytes16384DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Bytes16384DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataReader_ptr _tao_elem
  )
{
  TP_Test::Bytes16384DataReader_ptr _tao_objptr =
    TP_Test::Bytes16384DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Bytes16384DataReader>::insert (
      _tao_any,
      TP_Test::Bytes16384DataReader::_tao_any_destructor,
      TP_Test::_tc_Bytes16384DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Bytes16384DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Bytes16384DataReader>::extract (
        _tao_any,
        TP_Test::Bytes16384DataReader::_tao_any_destructor,
        TP_Test::_tc_Bytes16384DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex4Seq::_tao_any_destructor,
      TP_Test::_tc_Complex4Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4Seq>::insert (
      _tao_any,
      TP_Test::Complex4Seq::_tao_any_destructor,
      TP_Test::_tc_Complex4Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4Seq>::extract (
        _tao_any,
        TP_Test::Complex4Seq::_tao_any_destructor,
        TP_Test::_tc_Complex4Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex4TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex4TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex4TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex4TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex4TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex4TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex4DataWriter_ptr _tao_objptr =
    TP_Test::Complex4DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4DataWriter>::insert (
      _tao_any,
      TP_Test::Complex4DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex4DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4DataWriter>::extract (
        _tao_any,
        TP_Test::Complex4DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex4DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex4DataReader_ptr _tao_objptr =
    TP_Test::Complex4DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4DataReader>::insert (
      _tao_any,
      TP_Test::Complex4DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex4DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4DataReader>::extract (
        _tao_any,
        TP_Test::Complex4DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex4DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex8Seq::_tao_any_destructor,
      TP_Test::_tc_Complex8Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8Seq>::insert (
      _tao_any,
      TP_Test::Complex8Seq::_tao_any_destructor,
      TP_Test::_tc_Complex8Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8Seq>::extract (
        _tao_any,
        TP_Test::Complex8Seq::_tao_any_destructor,
        TP_Test::_tc_Complex8Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex8TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex8TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex8TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex8TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex8TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex8TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex8DataWriter_ptr _tao_objptr =
    TP_Test::Complex8DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8DataWriter>::insert (
      _tao_any,
      TP_Test::Complex8DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex8DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8DataWriter>::extract (
        _tao_any,
        TP_Test::Complex8DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex8DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex8DataReader_ptr _tao_objptr =
    TP_Test::Complex8DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8DataReader>::insert (
      _tao_any,
      TP_Test::Complex8DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex8DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8DataReader>::extract (
        _tao_any,
        TP_Test::Complex8DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex8DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex16Seq::_tao_any_destructor,
      TP_Test::_tc_Complex16Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16Seq>::insert (
      _tao_any,
      TP_Test::Complex16Seq::_tao_any_destructor,
      TP_Test::_tc_Complex16Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16Seq>::extract (
        _tao_any,
        TP_Test::Complex16Seq::_tao_any_destructor,
        TP_Test::_tc_Complex16Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex16TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex16TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex16TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex16TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex16TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex16TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex16DataWriter_ptr _tao_objptr =
    TP_Test::Complex16DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16DataWriter>::insert (
      _tao_any,
      TP_Test::Complex16DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex16DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16DataWriter>::extract (
        _tao_any,
        TP_Test::Complex16DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex16DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex16DataReader_ptr _tao_objptr =
    TP_Test::Complex16DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16DataReader>::insert (
      _tao_any,
      TP_Test::Complex16DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex16DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16DataReader>::extract (
        _tao_any,
        TP_Test::Complex16DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex16DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex32Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex32Seq::_tao_any_destructor,
      TP_Test::_tc_Complex32Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex32Seq>::insert (
      _tao_any,
      TP_Test::Complex32Seq::_tao_any_destructor,
      TP_Test::_tc_Complex32Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex32Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex32Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex32Seq>::extract (
        _tao_any,
        TP_Test::Complex32Seq::_tao_any_destructor,
        TP_Test::_tc_Complex32Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex32TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex32TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex32TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex32TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex32TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex32TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex32TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex32TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex32DataWriter_ptr _tao_objptr =
    TP_Test::Complex32DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex32DataWriter>::insert (
      _tao_any,
      TP_Test::Complex32DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex32DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex32DataWriter>::extract (
        _tao_any,
        TP_Test::Complex32DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex32DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex32DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex32DataReader_ptr _tao_objptr =
    TP_Test::Complex32DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex32DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex32DataReader>::insert (
      _tao_any,
      TP_Test::Complex32DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex32DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex32DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex32DataReader>::extract (
        _tao_any,
        TP_Test::Complex32DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex32DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex64Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex64Seq::_tao_any_destructor,
      TP_Test::_tc_Complex64Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex64Seq>::insert (
      _tao_any,
      TP_Test::Complex64Seq::_tao_any_destructor,
      TP_Test::_tc_Complex64Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex64Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex64Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex64Seq>::extract (
        _tao_any,
        TP_Test::Complex64Seq::_tao_any_destructor,
        TP_Test::_tc_Complex64Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex64TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex64TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex64TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex64TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex64TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex64TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex64TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex64TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex64DataWriter_ptr _tao_objptr =
    TP_Test::Complex64DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex64DataWriter>::insert (
      _tao_any,
      TP_Test::Complex64DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex64DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex64DataWriter>::extract (
        _tao_any,
        TP_Test::Complex64DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex64DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex64DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex64DataReader_ptr _tao_objptr =
    TP_Test::Complex64DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex64DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex64DataReader>::insert (
      _tao_any,
      TP_Test::Complex64DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex64DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex64DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex64DataReader>::extract (
        _tao_any,
        TP_Test::Complex64DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex64DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex128Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex128Seq::_tao_any_destructor,
      TP_Test::_tc_Complex128Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex128Seq>::insert (
      _tao_any,
      TP_Test::Complex128Seq::_tao_any_destructor,
      TP_Test::_tc_Complex128Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex128Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex128Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex128Seq>::extract (
        _tao_any,
        TP_Test::Complex128Seq::_tao_any_destructor,
        TP_Test::_tc_Complex128Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex128TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex128TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex128TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex128TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex128TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex128TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex128TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex128TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex128DataWriter_ptr _tao_objptr =
    TP_Test::Complex128DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex128DataWriter>::insert (
      _tao_any,
      TP_Test::Complex128DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex128DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex128DataWriter>::extract (
        _tao_any,
        TP_Test::Complex128DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex128DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex128DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex128DataReader_ptr _tao_objptr =
    TP_Test::Complex128DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex128DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex128DataReader>::insert (
      _tao_any,
      TP_Test::Complex128DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex128DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex128DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex128DataReader>::extract (
        _tao_any,
        TP_Test::Complex128DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex128DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex256Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex256Seq::_tao_any_destructor,
      TP_Test::_tc_Complex256Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex256Seq>::insert (
      _tao_any,
      TP_Test::Complex256Seq::_tao_any_destructor,
      TP_Test::_tc_Complex256Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex256Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex256Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex256Seq>::extract (
        _tao_any,
        TP_Test::Complex256Seq::_tao_any_destructor,
        TP_Test::_tc_Complex256Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex256TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex256TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex256TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex256TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex256TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex256TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex256TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex256TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex256DataWriter_ptr _tao_objptr =
    TP_Test::Complex256DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex256DataWriter>::insert (
      _tao_any,
      TP_Test::Complex256DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex256DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex256DataWriter>::extract (
        _tao_any,
        TP_Test::Complex256DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex256DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex256DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex256DataReader_ptr _tao_objptr =
    TP_Test::Complex256DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex256DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex256DataReader>::insert (
      _tao_any,
      TP_Test::Complex256DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex256DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex256DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex256DataReader>::extract (
        _tao_any,
        TP_Test::Complex256DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex256DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex512Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex512Seq::_tao_any_destructor,
      TP_Test::_tc_Complex512Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex512Seq>::insert (
      _tao_any,
      TP_Test::Complex512Seq::_tao_any_destructor,
      TP_Test::_tc_Complex512Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex512Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex512Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex512Seq>::extract (
        _tao_any,
        TP_Test::Complex512Seq::_tao_any_destructor,
        TP_Test::_tc_Complex512Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex512TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex512TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex512TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex512TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex512TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex512TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex512TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex512TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex512DataWriter_ptr _tao_objptr =
    TP_Test::Complex512DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex512DataWriter>::insert (
      _tao_any,
      TP_Test::Complex512DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex512DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex512DataWriter>::extract (
        _tao_any,
        TP_Test::Complex512DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex512DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex512DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex512DataReader_ptr _tao_objptr =
    TP_Test::Complex512DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex512DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex512DataReader>::insert (
      _tao_any,
      TP_Test::Complex512DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex512DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex512DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex512DataReader>::extract (
        _tao_any,
        TP_Test::Complex512DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex512DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex1024Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex1024Seq::_tao_any_destructor,
      TP_Test::_tc_Complex1024Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex1024Seq>::insert (
      _tao_any,
      TP_Test::Complex1024Seq::_tao_any_destructor,
      TP_Test::_tc_Complex1024Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex1024Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex1024Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex1024Seq>::extract (
        _tao_any,
        TP_Test::Complex1024Seq::_tao_any_destructor,
        TP_Test::_tc_Complex1024Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex1024TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex1024TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex1024TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex1024TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex1024TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex1024TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex1024TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex1024TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex1024DataWriter_ptr _tao_objptr =
    TP_Test::Complex1024DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex1024DataWriter>::insert (
      _tao_any,
      TP_Test::Complex1024DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex1024DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex1024DataWriter>::extract (
        _tao_any,
        TP_Test::Complex1024DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex1024DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex1024DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex1024DataReader_ptr _tao_objptr =
    TP_Test::Complex1024DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex1024DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex1024DataReader>::insert (
      _tao_any,
      TP_Test::Complex1024DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex1024DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex1024DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex1024DataReader>::extract (
        _tao_any,
        TP_Test::Complex1024DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex1024DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex2048Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex2048Seq::_tao_any_destructor,
      TP_Test::_tc_Complex2048Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex2048Seq>::insert (
      _tao_any,
      TP_Test::Complex2048Seq::_tao_any_destructor,
      TP_Test::_tc_Complex2048Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex2048Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex2048Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex2048Seq>::extract (
        _tao_any,
        TP_Test::Complex2048Seq::_tao_any_destructor,
        TP_Test::_tc_Complex2048Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex2048TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex2048TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex2048TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex2048TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex2048TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex2048TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex2048TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex2048TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex2048DataWriter_ptr _tao_objptr =
    TP_Test::Complex2048DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex2048DataWriter>::insert (
      _tao_any,
      TP_Test::Complex2048DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex2048DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex2048DataWriter>::extract (
        _tao_any,
        TP_Test::Complex2048DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex2048DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex2048DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex2048DataReader_ptr _tao_objptr =
    TP_Test::Complex2048DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex2048DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex2048DataReader>::insert (
      _tao_any,
      TP_Test::Complex2048DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex2048DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex2048DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex2048DataReader>::extract (
        _tao_any,
        TP_Test::Complex2048DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex2048DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex4096Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex4096Seq::_tao_any_destructor,
      TP_Test::_tc_Complex4096Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex4096Seq>::insert (
      _tao_any,
      TP_Test::Complex4096Seq::_tao_any_destructor,
      TP_Test::_tc_Complex4096Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex4096Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex4096Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex4096Seq>::extract (
        _tao_any,
        TP_Test::Complex4096Seq::_tao_any_destructor,
        TP_Test::_tc_Complex4096Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex4096TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex4096TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4096TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex4096TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex4096TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4096TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex4096TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex4096TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex4096DataWriter_ptr _tao_objptr =
    TP_Test::Complex4096DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4096DataWriter>::insert (
      _tao_any,
      TP_Test::Complex4096DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex4096DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4096DataWriter>::extract (
        _tao_any,
        TP_Test::Complex4096DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex4096DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex4096DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex4096DataReader_ptr _tao_objptr =
    TP_Test::Complex4096DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex4096DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex4096DataReader>::insert (
      _tao_any,
      TP_Test::Complex4096DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex4096DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex4096DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex4096DataReader>::extract (
        _tao_any,
        TP_Test::Complex4096DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex4096DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex8192Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex8192Seq::_tao_any_destructor,
      TP_Test::_tc_Complex8192Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex8192Seq>::insert (
      _tao_any,
      TP_Test::Complex8192Seq::_tao_any_destructor,
      TP_Test::_tc_Complex8192Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex8192Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex8192Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex8192Seq>::extract (
        _tao_any,
        TP_Test::Complex8192Seq::_tao_any_destructor,
        TP_Test::_tc_Complex8192Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex8192TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex8192TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8192TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex8192TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex8192TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8192TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex8192TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex8192TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex8192DataWriter_ptr _tao_objptr =
    TP_Test::Complex8192DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8192DataWriter>::insert (
      _tao_any,
      TP_Test::Complex8192DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex8192DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8192DataWriter>::extract (
        _tao_any,
        TP_Test::Complex8192DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex8192DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex8192DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex8192DataReader_ptr _tao_objptr =
    TP_Test::Complex8192DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex8192DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex8192DataReader>::insert (
      _tao_any,
      TP_Test::Complex8192DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex8192DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex8192DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex8192DataReader>::extract (
        _tao_any,
        TP_Test::Complex8192DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex8192DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const TP_Test::Complex16384Seq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384Seq>::insert_copy (
      _tao_any,
      TP_Test::Complex16384Seq::_tao_any_destructor,
      TP_Test::_tc_Complex16384Seq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<TP_Test::Complex16384Seq>::insert (
      _tao_any,
      TP_Test::Complex16384Seq::_tao_any_destructor,
      TP_Test::_tc_Complex16384Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384Seq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const TP_Test::Complex16384Seq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const TP_Test::Complex16384Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<TP_Test::Complex16384Seq>::extract (
        _tao_any,
        TP_Test::Complex16384Seq::_tao_any_destructor,
        TP_Test::_tc_Complex16384Seq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384TypeSupportInterface>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384TypeSupportInterface>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384TypeSupportInterface>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384TypeSupportInterface_ptr _tao_elem
  )
{
  TP_Test::Complex16384TypeSupportInterface_ptr _tao_objptr =
    TP_Test::Complex16384TypeSupportInterface::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384TypeSupportInterface_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16384TypeSupportInterface>::insert (
      _tao_any,
      TP_Test::Complex16384TypeSupportInterface::_tao_any_destructor,
      TP_Test::_tc_Complex16384TypeSupportInterface,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384TypeSupportInterface_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16384TypeSupportInterface>::extract (
        _tao_any,
        TP_Test::Complex16384TypeSupportInterface::_tao_any_destructor,
        TP_Test::_tc_Complex16384TypeSupportInterface,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataWriter>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataWriter>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataWriter>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384DataWriter_ptr _tao_elem
  )
{
  TP_Test::Complex16384DataWriter_ptr _tao_objptr =
    TP_Test::Complex16384DataWriter::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384DataWriter_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16384DataWriter>::insert (
      _tao_any,
      TP_Test::Complex16384DataWriter::_tao_any_destructor,
      TP_Test::_tc_Complex16384DataWriter,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384DataWriter_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16384DataWriter>::extract (
        _tao_any,
        TP_Test::Complex16384DataWriter::_tao_any_destructor,
        TP_Test::_tc_Complex16384DataWriter,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataReader>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataReader>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

ACE_TEMPLATE_SPECIALIZATION
CORBA::Boolean
TAO::Any_Impl_T<TP_Test::Complex16384DataReader>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384DataReader_ptr _tao_elem
  )
{
  TP_Test::Complex16384DataReader_ptr _tao_objptr =
    TP_Test::Complex16384DataReader::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    TP_Test::Complex16384DataReader_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<TP_Test::Complex16384DataReader>::insert (
      _tao_any,
      TP_Test::Complex16384DataReader::_tao_any_destructor,
      TP_Test::_tc_Complex16384DataReader,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    TP_Test::Complex16384DataReader_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<TP_Test::Complex16384DataReader>::extract (
        _tao_any,
        TP_Test::Complex16384DataReader::_tao_any_destructor,
        TP_Test::_tc_Complex16384DataReader,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_QuitMsgSeq_CPP_
#define _TAO_CDR_OP_TP_Test_QuitMsgSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::QuitMsgSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::QuitMsgSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_QuitMsgSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes4Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes4Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes4Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes4Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes4Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes8Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes8Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes8Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes8Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes8Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes16Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes16Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes16Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes16Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes16Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes32Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes32Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes32Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes32Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes32Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes64Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes64Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes64Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes64Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes64Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes128Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes128Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes128Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes128Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes128Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes256Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes256Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes256Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes256Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes256Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes512Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes512Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes512Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes512Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes512Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes1024Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes1024Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes1024Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes1024Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes1024Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes2048Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes2048Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes2048Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes2048Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes2048Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes4096Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes4096Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes4096Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes4096Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes4096Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes8192Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes8192Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes8192Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes8192Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes8192Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Bytes16384Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Bytes16384Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Bytes16384Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Bytes16384Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Bytes16384Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex4Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex4Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex4Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex4Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex4Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex8Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex8Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex8Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex8Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex8Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex16Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex16Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex16Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex16Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex16Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex32Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex32Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex32Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex32Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex32Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex64Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex64Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex64Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex64Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex64Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex128Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex128Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex128Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex128Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex128Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex256Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex256Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex256Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex256Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex256Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex512Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex512Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex512Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex512Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex512Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex1024Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex1024Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex1024Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex1024Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex1024Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex2048Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex2048Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex2048Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex2048Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex2048Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex4096Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex4096Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex4096Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex4096Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex4096Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex8192Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex8192Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex8192Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex8192Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex8192Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:95

#if !defined _TAO_CDR_OP_TP_Test_Complex16384Seq_CPP_
#define _TAO_CDR_OP_TP_Test_Complex16384Seq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const TP_Test::Complex16384Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    TP_Test::Complex16384Seq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_TP_Test_Complex16384Seq_CPP_ */

